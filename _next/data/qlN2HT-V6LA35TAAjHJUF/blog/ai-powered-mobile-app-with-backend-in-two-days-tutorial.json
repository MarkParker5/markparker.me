{"pageProps":{"article":{"id":"ai-powered-mobile-app-with-backend-in-two-days-tutorial","date":"2024-5-5","date_pretty":"May 5th, 2024","read_time":"15 min","title":"AI-powered Mobile App with Backend in Two Days (Tutorial)","description":"This article delves into the nuts and bolts of creating a Proof of Concept (PoC) of a mobile app built with SwiftUI framework and a backend using FastAPI. As an extra, I'll demonstrate effective architecture patterns for SwiftUI apps, specifically MVVMP combined with SOLID principles and Dependency Injection (DI). For android, the code can be easily translated to Kotlin using Jetpack Compose Framework almost without changes.","keywords":["AI app development","AI startup development","Backend for mobile app","ChatGPT in mobile apps","clean code","Code architecture in app development","Debugging","Decoupling","Dependency Injection","Design patterns","DRY principle","Encapsulation","FastAPI","FastAPI backend development","good software architecture","Hackathon","Hackathon project guide","Healthcare mobile app development","iOS app","iOS app development","KISS principle","Minimal Viable Product development","MVP","OpenAI API integration","PoC","Proof of Concept app","Proof of Concept app development","Protocol-oriented programming","Python","Rapid prototyping","Refactoring","software architecture","Software development best practices","Software engineering","SwiftUI","SwiftUI MVVMP pattern","SwiftUI tutorial","Tutorial for app developers","Xcode"],"tweetId":""},"mdxBody":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    ul: \"ul\",\n    li: \"li\",\n    a: \"a\",\n    h2: \"h2\",\n    ol: \"ol\",\n    strong: \"strong\",\n    h3: \"h3\",\n    pre: \"pre\",\n    code: \"code\",\n    em: \"em\",\n    blockquote: \"blockquote\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"Previous articles:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"/blog/how-we-built-an-ai-startup-in-a-weekend-hackathon-in-germany\",\n          children: \"How We Built an AI Startup in a Weekend Hackathon in Germany\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"/blog/house-md-ai-diagnostician-in-your-phone-passing-the-torch-and-entrusting-a-startup-to-capable-hands\",\n          children: \"Dr. House - AI Diagnostician in Your Phone: Passing the Startup Torch\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This article delves into the nuts and bolts of creating a Proof of Concept (PoC) of a mobile app built with the SwiftUI framework and a backend using FastAPI. As an extra, I'll demonstrate effective architecture patterns for SwiftUI apps, specifically MVVMP combined with SOLID principles and Dependency Injection (DI). For android, the code can be easily translated to Kotlin using Jetpack Compose Framework almost without changes.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Why We Need a Backend\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Someone might say that you can just cram all the logic into the application, send requests to chatgpt directly and make a backendless app. And I agree, it is indeed possible (and I'll show it later), but the backend provides several important advantages.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The backend serves as the backbone for any sophisticated app, especially those requiring secure data management, business logic processing, and service integration. Here’s why a robust backend is crucial:\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"Security\"\n          }), \": A backend helps protect sensitive data and user authentication tokens from MITM (Man-in-the-Middle) attacks. It acts as a secure gateway between the user's device and the database or external services, ensuring that all data exchanges are encrypted and authenticated.\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"Control Over Service Usage\"\n          }), \": By managing APIs and user interactions through the backend, you can monitor and control how the app is used. This includes throttling to manage load, preventing abuse, and ensuring that resources are used efficiently.\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"Database Integration\"\n          }), \": A backend allows for seamless integration with databases, enabling dynamic data storage, retrieval, and real-time updates. This is essential for apps that require user accounts, store user preferences, or need to retrieve large amounts of data quickly and securely.\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"Subscription and Freemium Models\"\n          }), \": Implementing subscription services or a freemium model requires a backend to handle billing, track usage, and manage user tiers. The backend can securely process payments and subscriptions, providing a seamless user experience while ensuring compliance with data protection regulations.\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"Scalability and Maintenance\"\n          }), \": With a backend, you can scale your application more effectively. Server-side logic can be updated without needing to push updates to the client, facilitating easier maintenance and quicker rollouts of new features.\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In essence, a backend is not just about functionality — it's about creating a secure, scalable, and sustainable environment for your app to thrive.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Explaining the Tech Stack\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"SwiftUI\"\n        }), \": The go-to for native iOS apps now that UIKit is on its way out. It's declarative and streamlined, with XCode as the indispensable editor. For android, the code can be easily translated to Kotlin using Jetpack Compose.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"FastAPI\"\n        }), \": Chosen for the backend for its speed, minimal boilerplate, and declarative nature, edited with the superb Zed.dev.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"ChatGPT API\"\n        }), \": Used here as a large language model (LLM); choice may vary based on the need for customization (see [Technical Info](github.com/HouseMDAI/house-notebook/blob/main/Technical Info.md)).\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Ngrok\"\n        }), \": Implements tunneling with a simple CLI command to expose your local server to the internet.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Building the iOS App\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Theory: Architecture Patterns\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"Model View ViewModel Presenter (MVVMP)\"\n          }), \":\"]\n        }), \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: \"Model\"\n            }), \": Represents the data structures used in the app, such as Question, Answer, Questionary, and FilledQuestionary. These models are simple and only hold data, following the KISS principle.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: \"View\"\n            }), \": SwiftUI views are responsible only for UI presentation and delegate all data and logic to presenters. They contain no business logic and are designed to be simple and focused on UI rendering.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: \"ViewModel\"\n            }), \": In SwiftUI, ViewModel is represented by ObservableObject, which serves as a data-only observable model. No methods or logic here.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: \"Presenter\"\n            }), \": The Presenter manages all logic related to the module (screen or view), but not the business logic. It communicates with the domain layer for business logic operations, such as interacting with APIs or managing data persistence.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: \"Domain Layer\"\n            }), \": This layer encapsulates the business logic of the application and interacts with external resources such as databases, APIs, or other services. It consists of several components, such as Services, Providers, Managers, Repositories, Mappers, Factories, etc.\"]\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"Actually, the MP in MVVMP stands for Mark Parker and the full form is \\\"Model View ViewModel by Mark Parker\\\"\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"SOLID Principles\"\n          }), \":\"]\n        }), \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: \"Single-responsibility Principle\"\n            }), \": Each class should have only one reason to change.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: \"Open-closed Principle\"\n            }), \": Components should be open for extension but closed for modification.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: \"Liskov Substitution Principle\"\n            }), \": Objects of a superclass should be replaceable with objects of subclasses.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: \"Interface Segregation Principle\"\n            }), \": No client should be forced to depend on interfaces it doesn't use.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: \"Dependency Inversion Principle\"\n            }), \": Depend on abstractions, not concretes, facilitated by DI.\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"Dependency Injection (DI)\"\n          }), \": a programming technique in which an object or function receives other objects or functions that it requires, as opposed to creating them internally.\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Drafting the Backend\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.a, {\n        href: \"https://github.com/HouseMDAI/house-backend/blob/master/backend\",\n        children: \"backend's code\"\n      }), \" is quite simple. Endpoints (main.py):\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-python\",\n        children: \"from typing import Callable\\nimport json\\nfrom fastapi import FastAPI, Body, Request, Response\\nfrom .models import (Question, FilledQuestionary, DoctorResponseAnswer, DoctorResponseQuestionary)\\nfrom .user_card import UserCardSimple\\nfrom .prompting import get_response\\n\\n\\n@app.get(\\\"/onboarding\\\", response_model = DoctorResponseQuestionary)\\ndef onboarding():\\n    return DoctorResponseQuestionary(question=[Question(text=text) for text in UserCardSimple.__fields__.keys()])\\n\\n@app.post(\\\"/doctor\\\")\\ndef doctor(user_card: UserCardSimple, filled_questionary: FilledQuestionary, message: str = Body(...)):\\n    json_string = get_response(user_card, message, filled_questionary)\\n    loaded = json.loads(json_string.strip())\\n    return loaded\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"There are two endpoints. The \\\"onboarding\\\" provides a list of anamnesis questions that needs to be filled at the first launch of the app. Answers will be stored on the device and used for personalized future diagnosis. The \\\"doctor\\\" is the main endpoint: it generates questions based on earlier answers and user's card, or returns the result of diagnosis.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Models:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-python\",\n        children: \"from pydantic import BaseModel\\n\\n\\nclass Question(BaseModel):\\n    text: str\\n\\nclass FilledQuestionary(BaseModel):\\n    filled_questions: dict[str, str]\\n\\nclass DoctorResponseAnswer(BaseModel):\\n    text: str\\n\\nclass DoctorResponseQuestionary(BaseModel):\\n    questions: list[str]\\n\\nclass UserCardSimple(BaseModel):\\n    sex: str\\n    age: int\\n    weight: int\\n    height: int\\n    special_conditions: str\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Prompting:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-python\",\n        children: \"import os\\nfrom openai import OpenAI\\nfrom .models import FilledQuestionary\\n\\n\\napi_key = os.environ.get(\\\"API_KEY\\\")\\nclient = OpenAI(api_key=api_key)\\n\\ndef get_response(user_card: str, message: str, filled_questionary: FilledQuestionary, max_tokens=200):\\n    format_question = \\\"\\\"\\\"{\\\"questions\\\":[{\\\"text\\\":\\\"first question\\\"},{\\\"text\\\":\\\"second question\\\"}]}\\\"\\\"\\\"\\n    format_advice = \\\"\\\"\\\"{\\\"text\\\":\\\"Advice: Drink more water\\\"}\\\"\\\"\\\"\\n\\n    system_prompt = f\\\"\\\"\\\"\\n    You are a doctor that gives user an opportunity to swiftly check up health and diagnos an illness using anamnes and a short questionary.\\n    Your task is to ask short questions and give your opinion and advices.\\n    Your questions are accamulated in the filled questionary, which is empty in the first itteration.\\n\\n    Strive to about 1-2 questions per iteration and up to 6 questions in total (can be less). Questions must be short, clear, shouldn't repeat,\\n    and should be relevant to the user's health condition, and should require easy answers.\\n    Ask questions only in the json format {format_question}.\\n\\n    Number of answered questions: {len(filled_questionary.filled_questions)}\\n    If the Number of answered questions is more then 6, you should stop asking questions an`d provide an give your final opinion,\\n    an assumption or an advice in the json format {format_advice}.\\n    \\\"\\\"\\\"\\n\\n    prompt = f\\\"\\\"\\\"request message: {message}; anamnesis: {user_card}; filled questionary: {filled_questionary};\\\"\\\"\\\"\\n\\n    chat_completion = client.chat.completions.create(\\n        messages=[\\n            {\\n                \\\"role\\\": \\\"system\\\",\\n                \\\"content\\\": f\\\"{system_prompt}\\\",\\n            },\\n            {\\n                \\\"role\\\": \\\"user\\\",\\n                \\\"content\\\": f\\\"{prompt}\\\",\\n            },\\n        ],\\n        model=\\\"gpt-3.5-turbo\\\",\\n        max_tokens=max_tokens\\n    )\\n    return chat_completion.choices[0].message.content\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The prompting module utilizes OpenAI's GPT-3.5 to generate responses based on user input, anamnesis, and filled questionnaires. It prompts the user with relevant questions and advice for health diagnosis. As you can see, there is nothing complicated here. The code is elementary, and the prompt is just a set of clear instructions for the LLM.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Setup the env and run the server using \", _jsx(_components.code, {\n        children: \"fastapi dev main.py\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Details:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://fastapi.tiangolo.com/tutorial/first-steps\",\n          children: \"fastapi.tiangolo.com/tutorial/first-steps\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://pypi.org/project/openai\",\n          children: \"pypi.org/project/openai\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Making Localhost Accessible Over the Internet\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Sign up at ngrok.com and get an access token.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Install ngrok from ngrok.com/download.\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Run \", _jsx(_components.code, {\n          children: \"ngrok config add-authtoken <TOKEN>\"\n        }), \".\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Start the service with \", _jsx(_components.code, {\n          children: \"ngrok http http://localhost:8080\"\n        }), \" (adjust the port as necessary).\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Find detailed setup instructions at \", _jsx(_components.a, {\n        href: \"https://ngrok.com/docs/getting-started\",\n        children: \"ngrok documentation\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Coding the App\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"I won't show the entire source code here, this is what GitHub is for. Find the code at: \", _jsx(_components.a, {\n        href: \"https://github.com/HouseMDAI/house-ios/tree/main/HouseMDAI\",\n        children: \"HouseMDAI iOS App\"\n      }), \". Instead, I'll focus only on the important (IMO) points.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Let's start with a quick description of the task: we need an app with a textfield on the home screen, ability to ask a set of dynamic questions, and show the answer. Also, we require a one-time onboarding. Okay, let's code.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"First thing first, we need some models, and they are pretty simple (KISS principle).\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-swift\",\n        children: \"struct Question {\\n    var text: String\\n}\\n\\nstruct Answer {\\n    var text: String\\n}\\n\\nstruct Questionary {\\n    var questions: [Question]\\n}\\n\\nstruct FilledQuestionary {\\n    var filledQuestions: [String: String]\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Now, let's do the onboarding. Keep following the KISS and SRP (Single Responsibility Principle), no business logic in views either, only UI. In this case, just the list of questions with scroll. All data and logic is delegated to the presenter. The only interesting thing here is a small helper method \", _jsx(_components.code, {\n        children: \"bindingForQuestion\"\n      }), \", which probably should be in the presenter but it doesn't matter now.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-swift\",\n        children: \"import SwiftUI\\n\\nstruct OnboardingView: View {\\n\\n    @StateObject var presenter: OnboardingPresenter\\n\\n    var body: some View {\\n        ScrollView {\\n            Spacer()\\n            VStack {\\n                ForEach(presenter.questions.questions) { question in\\n                    VStack {\\n                        Text(question.text)\\n                        TextField(\\\"\\\", text: bindingForQuestion(question))\\n                            .formItem()\\n                    }\\n                    .padding()\\n                }\\n            }.padding()\\n\\n            Button(\\\"Save\\\", action: presenter.save)\\n            Spacer()\\n        }\\n    }\\n\\n    private func bindingForQuestion(_ question: Question) -> Binding<String> {\\n        Binding(\\n            get: { presenter.answers.filledQuestions[question.text] ?? \\\"\\\" },\\n            set: { presenter.answers.filledQuestions[question.text] = $0 }\\n        )\\n    }\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"You will be surprised, but there is no business logic in the presenter either!\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-swift\",\n        children: \"class OnboardingPresenter: ObservableObject {\\n\\n    @Published public var answers: FilledQuestionary\\n    private(set) public var questions: Questionary\\n    private var completion: (FilledQuestionary) -> Void\\n\\n    init(questions: Questionary, answers: FilledQuestionary, completion: @escaping (FilledQuestionary) -> Void) {\\n        self.questions = questions\\n        self.answers = answers\\n        self.completion = completion\\n    }\\n\\n    func save() {\\n        completion(answers)\\n    }\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Still everything is \", _jsx(_components.em, {\n        children: \"simple, stupid\"\n      }), \", and have only a \", _jsx(_components.em, {\n        children: \"single responsibility\"\n      }), \". Presenter must contain only the logic of its view. App-level business-logic is out of its jurisdiction, so the presenter is just delegating it to the top.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Also, you can see that both View and Presenter don't instantiate any of the dependencies but receive them as init parameters. This follows the Dependency Inversion Principle, where high-level modules should not depend on low-level modules, but both should depend on abstractions. This allows for flexibility and easier testing, as well as making it straightforward to replace dependencies or inject mocks for testing purposes.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Using the Dependency Injection Pattern, dependencies are provided from outside the class rather than being instantiated internally. This promotes decoupling and allows for easier maintenance and testing.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Although protocols are not explicitly used in this example, it's worth mentioning that protocols can play a crucial role in code, especially for abstraction and easier testing. By defining protocols for views, presenters, and dependencies, it becomes easier to swap out implementations or provide mocks during testing.\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"If you're considering using protocols in SwiftUI Views, there's an important consideration to keep in mind. Since View in SwiftUI is a structure, it requires explicit specification of its property types. This means you'll need to make it a generic structure and pass the type through all the call stack, resulting in a lot of boilerplate code.\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"However, there's an alternative approach offered by \", _jsx(_components.a, {\n          href: \"https://github.com/MarkParker5/AnyObservableObject\",\n          children: \"MarkParker5/AnyObservableObject\"\n        }), \". This library works similarly to native SwiftUI property wrappers but removes the compile-time type check in favor of a runtime one. While this approach may introduce some risks, they are easily mitigated by writing elementary Xcode tests that simply instantiate the views in the same way you do it at runtime.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"By using this alternative, you can simplify your code and streamline the process of working with protocols in SwiftUI Views.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"So, if the presenter doesn't contain the business logic, then who does? This is the task for the domain layer, which usually contains Services, Providers, and Managers. They have very similar destiny and the difference between them still is a subject of discussions. Let's create the \", _jsx(_components.code, {\n        children: \"OnboardingProvider\"\n      }), \" that will contain all business-logic of the onboarding process.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-swift\",\n        children: \"class OnboardingProvider: ObservableObject {\\n\\n    init() {\\n        loadFilledOnboardingFromDefaults()\\n    }\\n\\n    // MARK: Interface\\n\\n\\t@Published private(set) var needsOnboarding: Bool = true\\n\\n    private(set) var filledOnboarding: FilledQuestionary? {\\n        didSet {\\n            if let filledOnboarding {\\n                saveFilledOnboardingToDefaults(filledQuestionary: filledOnboarding)\\n            }\\n        }\\n    }\\n\\n    func getOnboardingQuestionary() -> Questionary {\\n        // NOTE: it's better to take the questions from the backend\\n        Questionary(questions: [\\n            Question(text: \\\"sex\\\"),\\n            Question(text: \\\"age\\\"),\\n            Question(text: \\\"weight\\\"),\\n            Question(text: \\\"height\\\"),\\n            Question(text: \\\"special_conditions\\\"),\\n        ])\\n    }\\n\\n    func saveOnboardingAnswers(filledQuestionary: FilledQuestionary) {\\n        needsOnboarding = false\\n        filledOnboarding = filledQuestionary\\n    }\\n\\n    // MARK: - Private\\n\\n    private func saveFilledOnboardingToDefaults(filledQuestionary: FilledQuestionary) {\\n        UserDefaults.standard.removeObject(forKey: \\\"filledOnboarding\\\")\\n        let encoder = JSONEncoder()\\n        let encoded = try! encoder.encode(filledQuestionary)\\n        UserDefaults.standard.set(encoded, forKey: \\\"filledOnboarding\\\")\\n    }\\n\\n    private func loadFilledOnboardingFromDefaults() {\\n        guard let object = UserDefaults.standard.object(forKey: \\\"filledOnboarding\\\") else {\\n            needsOnboarding = true\\n            return\\n        }\\n        let savedFilledQuestionary = object as! Data\\n        let decoder = JSONDecoder()\\n        let loadedQuestionary = try! decoder.decode(FilledQuestionary.self, from: savedFilledQuestionary)\\n        self.filledOnboarding = loadedQuestionary\\n        self.needsOnboarding = false\\n    }\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Again, it handles only one responsibility: managing the business logic of the onboarding process. This \", _jsx(_components.em, {\n        children: \"encapsulation\"\n      }), \" allows other classes to interact with it without needing to worry about its internal implementation details, promoting a cleaner and more maintainable codebase.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now, let's put everything together in the entry point.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-swift\",\n        children: \"import SwiftUI\\n\\n@main\\nstruct HouseMDAI: App {\\n\\n    @StateObject private var onboardingProvider: OnboardingProvider\\n    @StateObject private var onboardingPresenter: OnboardingPresenter\\n    @StateObject private var homePresenter: HomePresenter\\n\\n    init() {\\n        let onboardingProvider = OnboardingProvider()\\n\\n        let onboardingPresenter = OnboardingPresenter(\\n            questions: onboardingProvider.getOnboardingQuestionary(),\\n            answers: FilledQuestionary(filledQuestions: [:]),\\n            completion: onboardingProvider.saveOnboardingAnswers\\n        )\\n\\n\\t    let doctor = BackendDoctorProvider(baseUrl: \\\"http://localhost:8000\\\")\\n        let homePresenter = HomePresenter(doctor: doctor)\\n\\n        _onboardingProvider = StateObject(wrappedValue: onboardingProvider)\\n        _onboardingPresenter = StateObject(wrappedValue: onboardingPresenter)\\n        _homePresenter = StateObject(wrappedValue: homePresenter)\\n    }\\n\\n    var body: some Scene {\\n        WindowGroup {\\n            if onboardingProvider.needsOnboarding {\\n                OnboardingView(presenter: onboardingPresenter)\\n            } else {\\n                TabView {\\n                    HomeView(presenter: homePresenter)\\n                    if let profile = onboardingProvider.filledOnboarding {\\n                        ProfileView(profile: profile)\\n                    }\\n                }\\n            }\\n        }\\n    } // body\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This SwiftUI app sets up its initial state using \", _jsx(_components.code, {\n        children: \"StateObject\"\n      }), \" property wrappers. It initializes an \", _jsx(_components.code, {\n        children: \"OnboardingProvider\"\n      }), \", \", _jsx(_components.code, {\n        children: \"OnboardingPresenter\"\n      }), \", and \", _jsx(_components.code, {\n        children: \"HomePresenter\"\n      }), \" in its init method. The \", _jsx(_components.code, {\n        children: \"OnboardingProvider\"\n      }), \" is responsible for managing onboarding-related data, while the \", _jsx(_components.code, {\n        children: \"OnboardingPresenter\"\n      }), \" handles the logic for the onboarding view. The \", _jsx(_components.code, {\n        children: \"HomePresenter\"\n      }), \" manages the main home view.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The body of the app's scene checks if onboarding is needed. If so, it presents the \", _jsx(_components.code, {\n        children: \"OnboardingView\"\n      }), \" with the \", _jsx(_components.code, {\n        children: \"OnboardingPresenter\"\n      }), \". Otherwise, it presents a \", _jsx(_components.code, {\n        children: \"TabView\"\n      }), \" containing the \", _jsx(_components.code, {\n        children: \"HomeView\"\n      }), \" with the \", _jsx(_components.code, {\n        children: \"HomePresenter\"\n      }), \" and, if available, the \", _jsx(_components.code, {\n        children: \"ProfileView\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now it's time for the home view. The logic is simple:\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Get a message from user\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Using the message, request a list of questions from the backend\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Show the questions one by one using the native push navigation\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Add answers to the request and repeat 2-4 until the backend-doctor returns a final result\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Show the final result\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-swift\",\n        children: \"struct HomeView: View {\\n\\n    @StateObject var presenter: HomePresenter\\n\\n    var body: some View {\\n        NavigationStack(path: $presenter.navigationPath) {\\n            VStack {\\n\\t            // 1\\n                Text(\\\"How are you?\\\")\\n                TextField(\\\"...\\\", text: $presenter.message)\\n                    .lineLimit(5...10)\\n                    .formItem()\\n\\n\\t\\t\\t\\t// 2\\n                Button(\\\"Send\\\", action: presenter.onSend)\\n            }\\n            .padding()\\n            .navigationDestination(for: NavigationPage.self) { page in\\n                switch page {\\n                case .questinary(let questions, let answers):\\n\\t                // 3\\n                    QuestionaryView(\\n                        presenter: QuestionaryPresenter(\\n                            questions: questions,\\n                            answers: answers,\\n                            completion: presenter.onQuestionaryFilled\\n                        )\\n                    )\\n                case .answer(let string):\\n\\t                // 5\\n                    VStack {\\n                        Text(\\\"The doctor says...\\\")\\n                        Text(string)\\n                            .font(.title2)\\n                            .padding()\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Looks like I've missed the 4th point... or not? Since the view can't content any logic, this part in handled by its presenter.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-swift\",\n        children: \"enum NavigationPage: Hashable {\\n    case questinary(Questionary, FilledQuestionary)\\n    case answer(String)\\n}\\n\\nclass HomePresenter: ObservableObject {\\n\\n    @Published var message: String = \\\"\\\"\\n    @Published var navigationPath: [NavigationPage] = []\\n\\n    private let doctor: any DoctorProvider\\n\\n    init(message: String = \\\"\\\", doctor: any DoctorProvider) {\\n        self.message = message\\n        self.doctor = doctor\\n    }\\n\\n    func onSend() {\\n        Task {\\n            let answer = try! await doctor.sendMessage(message: message)\\n\\n            switch answer {\\n            case .questions(let questions):\\n                navigationPath.append(.questinary(questions, FilledQuestionary(filledQuestions: [:])))\\n            case .answer(let string):\\n                navigationPath.append(.answer(string))\\n            }\\n        }\\n    }\\n\\n    func onQuestionaryFilled(filled: FilledQuestionary) {\\n        Task {\\n            let answer = try! await doctor.sendAnswers(message: message, answers: filled)\\n\\n            switch answer {\\n            case .questions(let newQuestions):\\n                navigationPath.append(.questinary(newQuestions, filled))\\n            case .answer(let string):\\n                navigationPath.append(.answer(string))\\n            }\\n        }\\n    }\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"It manages the user's message input and updates the navigation path based on responses from the backend.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Upon sending a message, the \", _jsx(_components.code, {\n        children: \"onSend()\"\n      }), \" method sends the message to the backend using the \", _jsx(_components.code, {\n        children: \"DoctorProvider\"\n      }), \" and awaits a response. Depending on the response type, it updates the navigation path to either display a set of questions or show a final answer.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Similarly, when a questionary is filled, the \", _jsx(_components.code, {\n        children: \"onQuestionaryFilled()\"\n      }), \" method sends the filled questionary to the backend and updates the navigation path accordingly.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"There's a slight code duplication here between the \", _jsx(_components.code, {\n        children: \"onSend()\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"onQuestionaryFilled()\"\n      }), \" methods, which could be refactored into a single method to handle both cases (DRY principle - Don't Repeat Yourself). However, this is left as an exercise for further refinement.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The Questionary module (View+Presenter) is almost a copy of the Onboarding and simply delegates the logic up to \", _jsx(_components.code, {\n        children: \"HomePresenter\"\n      }), \", so I don't see a need to show the code. Again, there is github for that.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The last things I want to show are two implementations of \", _jsx(_components.code, {\n        children: \"DoctorProvider\"\n      }), \" which the only responsibility is to call the API and return \", _jsx(_components.code, {\n        children: \"DoctorResponse\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-swift\",\n        children: \"protocol DoctorProvider {\\n    func sendMessage(message: String) async throws -> DoctorResponse\\n    func sendAnswers(message: String, answers: FilledQuestionary) async throws -> DoctorResponse\\n}\\n\\nenum DoctorResponse {\\n    case questions(Questionary)\\n    case answer(String)\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The first one uses our backend:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-swift\",\n        children: \"class BackendDoctorProvider: DoctorProvider {\\n\\n    private let baseUrl: String\\n\\n    init(baseUrl: String) {\\n        self.baseUrl = baseUrl\\n    }\\n\\n    func sendMessage(message: String) async throws -> DoctorResponse {\\n        try! await sendAnswers(message: message, answers: FilledQuestionary(filledQuestions: [:]))\\n    }\\n\\n    func sendAnswers(message: String, answers: FilledQuestionary) async throws -> DoctorResponse {\\n\\n        struct DoctorParams: Codable {\\n            var message: String\\n            var userCard: [String: String]\\n            var filledQuestionary: FilledQuestionary\\n        }\\n\\n        let onboard = OnboardingProvider() // TODO: DI\\n\\n        let paramsObject = DoctorParams(\\n            message: message,\\n            userCard: onboard.filledOnboarding!.filledQuestions,\\n            filledQuestionary: answers\\n        )\\n\\n        let encoder = JSONParameterEncoder.default\\n        encoder.encoder.keyEncodingStrategy = .convertToSnakeCase\\n\\n        let responseString = try await AF.request(\\n            baseUrl + \\\"/doctor\\\",\\n            method: .post,\\n            parameters: paramsObject,\\n            encoder: encoder\\n        ).serializingString().value\\n\\n        return try! DoctorResponse(from: responseString)\\n    }\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The second one calls openai api directly (backendless approach) and is almost a copy of the prompting module from the backend.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-swift\",\n        children: \"class PromptsProvider {\\n\\n    private(set) public var homeRole = \\\"\\\" // TODO: take from the backend\\n\\n    func message(message: String) -> String {\\n        return message\\n    }\\n\\n    func profile(profile: FilledQuestionary) -> String {\\n        return try! jsonify(object: profile)\\n    }\\n\\n    func answers(filled: FilledQuestionary) -> String {\\n        return try! jsonify(object: filled)\\n    }\\n\\n    // MARK: - Private\\n\\n    private func jsonify(object: Encodable) throws -> String {\\n        let coder = JSONEncoder()\\n        return String(data: try coder.encode(object), encoding: .utf8) ?? \\\"\\\"\\n    }\\n}\\n\\nclass DirectDoctorProvider: DoctorProvider {\\n\\n    private var openAI: OpenAI\\n\\n    init(apiToken: String) {\\n        openAI = OpenAI(apiToken: apiToken)\\n    }\\n\\n    func sendMessage(message: String) async throws -> DoctorResponse {\\n        try! await sendAnswers(message: message, answers: FilledQuestionary(filledQuestions: [:]))\\n    }\\n\\n    func sendAnswers(message: String, answers: FilledQuestionary) async throws -> DoctorResponse {\\n        let promptProvider = PromptsProvider() // TODO: DI\\n        let profile = OnboardingProvider().filledOnboarding! // TODO: DI\\n\\n        let query = ChatQuery(model: .gpt3_5Turbo, messages: [\\n            Chat(role: .system, content: promptProvider.homeRole),\\n            Chat(role: .user, content: promptProvider.profile(profile: profile)),\\n            Chat(role: .user, content: promptProvider.message(message: message)),\\n            Chat(role: .user, content: promptProvider.answers(filled: answers)),\\n        ])\\n\\n        let result = try await openAI.chats(query: query)\\n        return try! DoctorResponse(from: result.choices[0].message.content ?? \\\"\\\")\\n    }\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Both classes implement the same protocol and are easily interchangeable via DI.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-swift\",\n        children: \"let doctor = BackendDoctorProvider(baseUrl: \\\"http://localhost:8000\\\")\\nlet homePresenter = HomePresenter(doctor: doctor)\\n\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-swift\",\n        children: \"let doctor = DirectDoctorProvider(apiToken: \\\"\\\")\\nlet homePresenter = HomePresenter(doctor: doctor)\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Another Example\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Explore a more refined example of this architecture in my project TwiTreads at \", _jsx(_components.a, {\n        href: \"https://github.com/MarkParker5/TwiTreads\",\n        children: \"github.com/MarkParker5/TwiTreads\"\n      })]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"What to Do Next\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"Integrate authentication and user database into the backend. Utilize the official FastAPI's template from \", _jsx(_components.a, {\n          href: \"https://fastapi.tiangolo.com/project-generation\",\n          children: \"FastAPI Project Generation\"\n        }), \".\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Implement authentication flow in the app.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Focus on enhancing the app's design to improve user experience. Let's make beautiful apps!\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Conclusion\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The projects and code links included serve as real-world examples to jumpstart your own development. Remember, the beauty of technology lies in iteration. Start simple, build a prototype, and continuously refine it. Each step forward brings you closer to mastering the art of software development and potentially the next big breakthrough in tech. Happy coding!\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}