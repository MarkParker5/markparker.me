<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>AI-powered Mobile App with Backend in Two Days (Tutorial) — Mark Parker</title><meta name="og:title" content="AI-powered Mobile App with Backend in Two Days (Tutorial) — Mark Parker"/><meta name="og:image" content="https://markparker.me/articles/ai-powered-mobile-app-with-backend-in-two-days-tutorial/meta.jpg"/><meta name="description" content="This article delves into the nuts and bolts of creating a Proof of Concept (PoC) of a mobile app built with SwiftUI framework and a backend using FastAPI. As an extra, I&#x27;ll demonstrate effective architecture patterns for SwiftUI apps, specifically MVVMP combined with SOLID principles and Dependency Injection (DI). For android, the code can be easily translated to Kotlin using Jetpack Compose Framework almost without changes."/><meta name="og:description" content="This article delves into the nuts and bolts of creating a Proof of Concept (PoC) of a mobile app built with SwiftUI framework and a backend using FastAPI. As an extra, I&#x27;ll demonstrate effective architecture patterns for SwiftUI apps, specifically MVVMP combined with SOLID principles and Dependency Injection (DI). For android, the code can be easily translated to Kotlin using Jetpack Compose Framework almost without changes."/><meta name="keywords" content="AI app development,AI startup development,Backend for mobile app,ChatGPT in mobile apps,clean code,Code architecture in app development,Debugging,Decoupling,Dependency Injection,Design patterns,DRY principle,Encapsulation,FastAPI,FastAPI backend development,good software architecture,Hackathon,Hackathon project guide,Healthcare mobile app development,iOS app,iOS app development,KISS principle,Minimal Viable Product development,MVP,OpenAI API integration,PoC,Proof of Concept app,Proof of Concept app development,Protocol-oriented programming,Python,Rapid prototyping,Refactoring,software architecture,Software development best practices,Software engineering,SwiftUI,SwiftUI MVVMP pattern,SwiftUI tutorial,Tutorial for app developers,Xcode"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:image" content="https://markparker.me/articles/ai-powered-mobile-app-with-backend-in-two-days-tutorial/meta.jpg"/><meta name="twitter:title" content="AI-powered Mobile App with Backend in Two Days (Tutorial)"/><meta name="twitter:description" content="This article delves into the nuts and bolts of creating a Proof of Concept (PoC) of a mobile app built with SwiftUI framework and a backend using FastAPI. As an extra, I&#x27;ll demonstrate effective architecture patterns for SwiftUI apps, specifically MVVMP combined with SOLID principles and Dependency Injection (DI). For android, the code can be easily translated to Kotlin using Jetpack Compose Framework almost without changes."/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"/><link rel="stylesheet" href="/highlight/styles/atom-one-light.min.css"/><link rel="stylesheet" href="/highlight/styles/atom-one-dark.min.css" media="(prefers-color-scheme: dark)"/><meta name="next-head-count" content="15"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-MPVB5GN2QR"></script><script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());

            gtag('config', 'G-MPVB5GN2QR');
          </script><link rel="icon" type="image/x-icon" href="/favicon.png"/><link rel="preload" href="/_next/static/css/d5d0e4d9d26237aa.css" as="style"/><link rel="stylesheet" href="/_next/static/css/d5d0e4d9d26237aa.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-fd1bc4a65a80e5c8.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-5aae0466a51ee992.js" defer=""></script><script src="/_next/static/chunks/pages/_app-5d27780da2e99e2e.js" defer=""></script><script src="/_next/static/chunks/623-5c77ec4bf18d9b30.js" defer=""></script><script src="/_next/static/chunks/66-925bae36a51a5c74.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-3b63c4068900db03.js" defer=""></script><script src="/_next/static/KuUflqe93Wvy0Z8W9uWO2/_buildManifest.js" defer=""></script><script src="/_next/static/KuUflqe93Wvy0Z8W9uWO2/_ssgManifest.js" defer=""></script></head><body class="text-primary bg-back dark:text-primary-dark dark:bg-back-dark"><div id="__next"><div class="mx-auto" style="max-width:90%;width:44rem"><header><a class="" href="/"><h1 class="text-center block mt-4 mb-1 text-4xl">Mark Parker</h1></a><div class="text-center"><a class="text-link1 hover:text-link1hover underline hover:no-underline" href="/">About</a> · <a class="text-link1 hover:text-link1hover underline hover:no-underline" href="/blog">Blog</a></div></header><hr class="mx-auto w-3/4 h-1px border-t-1 border-faded my-10"/><main><a style="position:fixed;top:0;left:80%;width:50px" target="_blank" rel="noreferrer noopener" href="https://twitter.com/intent/tweet?text=AI-powered+Mobile+App+with+Backend+in+Two+Days+%28Tutorial%29&amp;url=https%3A%2F%2Fmarkparker.me%2Fblog%2Fai-powered-mobile-app-with-backend-in-two-days-tutorial&amp;via=MarkParker_5"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 455.731 455.731" xml:space="preserve"> <g> <rect x="0" y="0" style="fill:#333" width="455.731" height="455.731"></rect> <path style="fill:#FFFFFF" d="M60.377,337.822c30.33,19.236,66.308,30.368,104.875,30.368c108.349,0,196.18-87.841,196.18-196.18 c0-2.705-0.057-5.39-0.161-8.067c3.919-3.084,28.157-22.511,34.098-35c0,0-19.683,8.18-38.947,10.107 c-0.038,0-0.085,0.009-0.123,0.009c0,0,0.038-0.019,0.104-0.066c1.775-1.186,26.591-18.079,29.951-38.207 c0,0-13.922,7.431-33.415,13.932c-3.227,1.072-6.605,2.126-10.088,3.103c-12.565-13.41-30.425-21.78-50.25-21.78 c-38.027,0-68.841,30.805-68.841,68.803c0,5.362,0.617,10.581,1.784,15.592c-5.314-0.218-86.237-4.755-141.289-71.423 c0,0-32.902,44.917,19.607,91.105c0,0-15.962-0.636-29.733-8.864c0,0-5.058,54.416,54.407,68.329c0,0-11.701,4.432-30.368,1.272 c0,0,10.439,43.968,63.271,48.077c0,0-41.777,37.74-101.081,28.885L60.377,337.822z"></path> </g> <g> </g> <g> </g> <g> </g> <g> </g> <g> </g> <g> </g> <g> </g> <g> </g> <g> </g> <g> </g> <g> </g> <g> </g> <g> </g> <g> </g> <g> </g> </svg></a><a class="text-link1 hover:text-link1hover underline hover:no-underline" href="/">&lt;-<!-- --> Back to home</a><div class="mt-5 mb-3"><p class="mb-2">Read on:</p><div class="inline-flex gap-5 items-center flex-wrap"><a href="https://twitter.com/markparker5/status/1795095306758926812" title="Twitter" class="" target="_blank"><i class="fab fa-twitter fa-xl"></i></a><a href="https://markparker5.medium.com/ai-powered-mobile-app-with-backend-in-two-days-mvvmp-architecture-overview-tutorial-cdaa51fb9216" title="Medium" class="" target="_blank"><i class="fab fa-medium fa-xl"></i></a><a href="https://markparker5.hashnode.dev/ai-powered-mobile-app-with-backend-in-two-days-mvvmp-architecture-overview-tutorial" title="Hashnode" class="" target="_blank"><i class="fab fa-hashnode fa-xl"></i></a><a href="https://dev.to/markparker5/ai-powered-mobile-app-with-backend-in-two-days-mvvmp-architecture-overview-tutorial-mh1" title="Dev.to" class="" target="_blank"><i class="fab fa-dev fa-xl"></i></a><a href="https://habr.com/ru/articles/816345/" title="Habr" class="" target="_blank"><i class="fas fa-comment fa-xl"></i></a></div></div><div class="mb-3 mt-1"><h1 class="text-3xl leading-tight font-bold">AI-powered Mobile App with Backend in Two Days (Tutorial)</h1><div class="italic mt-1 text-md opacity-50">Published on <!-- -->May 5th, 2024<!-- --> · <!-- -->15 min<!-- --> read</div></div><div class="markdown mb-10"><p>Previous articles:</p>
<ul>
<li><a class="text-link2-light hover:text-link2hover-light dark:text-link2-dark dark:hover:text-link2hover-dark font-semibold" href="/blog/how-we-built-an-ai-startup-in-a-weekend-hackathon-in-germany">How We Built an AI Startup in a Weekend Hackathon in Germany</a></li>
<li><a class="text-link2-light hover:text-link2hover-light dark:text-link2-dark dark:hover:text-link2hover-dark font-semibold" href="/blog/house-md-ai-diagnostician-in-your-phone-passing-the-torch-and-entrusting-a-startup-to-capable-hands">Dr. House - AI Diagnostician in Your Phone: Passing the Startup Torch</a></li>
</ul>
<p>This article delves into the nuts and bolts of creating a Proof of Concept (PoC) of a mobile app built with the SwiftUI framework and a backend using FastAPI. As an extra, I&#x27;ll demonstrate effective architecture patterns for SwiftUI apps, specifically MVVMP combined with SOLID principles and Dependency Injection (DI). For android, the code can be easily translated to Kotlin using Jetpack Compose Framework almost without changes.</p>
<h2>Why We Need a Backend</h2>
<p>Someone might say that you can just cram all the logic into the application, send requests to chatgpt directly and make a backendless app. And I agree, it is indeed possible (and I&#x27;ll show it later), but the backend provides several important advantages.</p>
<p>The backend serves as the backbone for any sophisticated app, especially those requiring secure data management, business logic processing, and service integration. Here’s why a robust backend is crucial:</p>
<ol>
<li>
<p><strong>Security</strong>: A backend helps protect sensitive data and user authentication tokens from MITM (Man-in-the-Middle) attacks. It acts as a secure gateway between the user&#x27;s device and the database or external services, ensuring that all data exchanges are encrypted and authenticated.</p>
</li>
<li>
<p><strong>Control Over Service Usage</strong>: By managing APIs and user interactions through the backend, you can monitor and control how the app is used. This includes throttling to manage load, preventing abuse, and ensuring that resources are used efficiently.</p>
</li>
<li>
<p><strong>Database Integration</strong>: A backend allows for seamless integration with databases, enabling dynamic data storage, retrieval, and real-time updates. This is essential for apps that require user accounts, store user preferences, or need to retrieve large amounts of data quickly and securely.</p>
</li>
<li>
<p><strong>Subscription and Freemium Models</strong>: Implementing subscription services or a freemium model requires a backend to handle billing, track usage, and manage user tiers. The backend can securely process payments and subscriptions, providing a seamless user experience while ensuring compliance with data protection regulations.</p>
</li>
<li>
<p><strong>Scalability and Maintenance</strong>: With a backend, you can scale your application more effectively. Server-side logic can be updated without needing to push updates to the client, facilitating easier maintenance and quicker rollouts of new features.</p>
</li>
</ol>
<p>In essence, a backend is not just about functionality — it&#x27;s about creating a secure, scalable, and sustainable environment for your app to thrive.</p>
<h2>Explaining the Tech Stack</h2>
<ul>
<li><strong>SwiftUI</strong>: The go-to for native iOS apps now that UIKit is on its way out. It&#x27;s declarative and streamlined, with XCode as the indispensable editor. For android, the code can be easily translated to Kotlin using Jetpack Compose.</li>
<li><strong>FastAPI</strong>: Chosen for the backend for its speed, minimal boilerplate, and declarative nature, edited with the superb Zed.dev.</li>
<li><strong>ChatGPT API</strong>: Used here as a large language model (LLM); choice may vary based on the need for customization (see [Technical Info](github.com/HouseMDAI/house-notebook/blob/main/Technical Info.md)).</li>
<li><strong>Ngrok</strong>: Implements tunneling with a simple CLI command to expose your local server to the internet.</li>
</ul>
<h2>Building the iOS App</h2>
<h3>Theory: Architecture Patterns</h3>
<ol>
<li>
<p><strong>Model View ViewModel Presenter (MVVMP)</strong>:</p>
<ul>
<li><strong>Model</strong>: Represents the data structures used in the app, such as Question, Answer, Questionary, and FilledQuestionary. These models are simple and only hold data, following the KISS principle.</li>
<li><strong>View</strong>: SwiftUI views are responsible only for UI presentation and delegate all data and logic to presenters. They contain no business logic and are designed to be simple and focused on UI rendering.</li>
<li><strong>ViewModel</strong>: In SwiftUI, ViewModel is represented by ObservableObject, which serves as a data-only observable model. No methods or logic here.</li>
<li><strong>Presenter</strong>: The Presenter manages all logic related to the module (screen or view), but not the business logic. It communicates with the domain layer for business logic operations, such as interacting with APIs or managing data persistence.</li>
<li><strong>Domain Layer</strong>: This layer encapsulates the business logic of the application and interacts with external resources such as databases, APIs, or other services. It consists of several components, such as Services, Providers, Managers, Repositories, Mappers, Factories, etc.</li>
<li>Actually, the MP in MVVMP stands for Mark Parker and the full form is &quot;Model View ViewModel by Mark Parker&quot;</li>
</ul>
</li>
<li>
<p><strong>SOLID Principles</strong>:</p>
<ul>
<li><strong>Single-responsibility Principle</strong>: Each class should have only one reason to change.</li>
<li><strong>Open-closed Principle</strong>: Components should be open for extension but closed for modification.</li>
<li><strong>Liskov Substitution Principle</strong>: Objects of a superclass should be replaceable with objects of subclasses.</li>
<li><strong>Interface Segregation Principle</strong>: No client should be forced to depend on interfaces it doesn&#x27;t use.</li>
<li><strong>Dependency Inversion Principle</strong>: Depend on abstractions, not concretes, facilitated by DI.</li>
</ul>
</li>
<li>
<p><strong>Dependency Injection (DI)</strong>: a programming technique in which an object or function receives other objects or functions that it requires, as opposed to creating them internally.</p>
</li>
</ol>
<h2>Drafting the Backend</h2>
<p>The <a class="text-link2-light hover:text-link2hover-light dark:text-link2-dark dark:hover:text-link2hover-dark font-semibold" href="https://github.com/HouseMDAI/house-backend/blob/master/backend">backend&#x27;s code</a> is quite simple. Endpoints (main.py):</p>
<pre><code class="language-python">from typing import Callable
import json
from fastapi import FastAPI, Body, Request, Response
from .models import (Question, FilledQuestionary, DoctorResponseAnswer, DoctorResponseQuestionary)
from .user_card import UserCardSimple
from .prompting import get_response


@app.get(&quot;/onboarding&quot;, response_model = DoctorResponseQuestionary)
def onboarding():
    return DoctorResponseQuestionary(question=[Question(text=text) for text in UserCardSimple.__fields__.keys()])

@app.post(&quot;/doctor&quot;)
def doctor(user_card: UserCardSimple, filled_questionary: FilledQuestionary, message: str = Body(...)):
    json_string = get_response(user_card, message, filled_questionary)
    loaded = json.loads(json_string.strip())
    return loaded
</code></pre>
<p>There are two endpoints. The &quot;onboarding&quot; provides a list of anamnesis questions that needs to be filled at the first launch of the app. Answers will be stored on the device and used for personalized future diagnosis. The &quot;doctor&quot; is the main endpoint: it generates questions based on earlier answers and user&#x27;s card, or returns the result of diagnosis.</p>
<p>Models:</p>
<pre><code class="language-python">from pydantic import BaseModel


class Question(BaseModel):
    text: str

class FilledQuestionary(BaseModel):
    filled_questions: dict[str, str]

class DoctorResponseAnswer(BaseModel):
    text: str

class DoctorResponseQuestionary(BaseModel):
    questions: list[str]

class UserCardSimple(BaseModel):
    sex: str
    age: int
    weight: int
    height: int
    special_conditions: str
</code></pre>
<p>Prompting:</p>
<pre><code class="language-python">import os
from openai import OpenAI
from .models import FilledQuestionary


api_key = os.environ.get(&quot;API_KEY&quot;)
client = OpenAI(api_key=api_key)

def get_response(user_card: str, message: str, filled_questionary: FilledQuestionary, max_tokens=200):
    format_question = &quot;&quot;&quot;{&quot;questions&quot;:[{&quot;text&quot;:&quot;first question&quot;},{&quot;text&quot;:&quot;second question&quot;}]}&quot;&quot;&quot;
    format_advice = &quot;&quot;&quot;{&quot;text&quot;:&quot;Advice: Drink more water&quot;}&quot;&quot;&quot;

    system_prompt = f&quot;&quot;&quot;
    You are a doctor that gives user an opportunity to swiftly check up health and diagnos an illness using anamnes and a short questionary.
    Your task is to ask short questions and give your opinion and advices.
    Your questions are accamulated in the filled questionary, which is empty in the first itteration.

    Strive to about 1-2 questions per iteration and up to 6 questions in total (can be less). Questions must be short, clear, shouldn&#x27;t repeat,
    and should be relevant to the user&#x27;s health condition, and should require easy answers.
    Ask questions only in the json format {format_question}.

    Number of answered questions: {len(filled_questionary.filled_questions)}
    If the Number of answered questions is more then 6, you should stop asking questions an`d provide an give your final opinion,
    an assumption or an advice in the json format {format_advice}.
    &quot;&quot;&quot;

    prompt = f&quot;&quot;&quot;request message: {message}; anamnesis: {user_card}; filled questionary: {filled_questionary};&quot;&quot;&quot;

    chat_completion = client.chat.completions.create(
        messages=[
            {
                &quot;role&quot;: &quot;system&quot;,
                &quot;content&quot;: f&quot;{system_prompt}&quot;,
            },
            {
                &quot;role&quot;: &quot;user&quot;,
                &quot;content&quot;: f&quot;{prompt}&quot;,
            },
        ],
        model=&quot;gpt-3.5-turbo&quot;,
        max_tokens=max_tokens
    )
    return chat_completion.choices[0].message.content
</code></pre>
<p>The prompting module utilizes OpenAI&#x27;s GPT-3.5 to generate responses based on user input, anamnesis, and filled questionnaires. It prompts the user with relevant questions and advice for health diagnosis. As you can see, there is nothing complicated here. The code is elementary, and the prompt is just a set of clear instructions for the LLM.</p>
<p>Setup the env and run the server using <code>fastapi dev main.py</code>.</p>
<p>Details:</p>
<ul>
<li><a class="text-link2-light hover:text-link2hover-light dark:text-link2-dark dark:hover:text-link2hover-dark font-semibold" href="https://fastapi.tiangolo.com/tutorial/first-steps">fastapi.tiangolo.com/tutorial/first-steps</a></li>
<li><a class="text-link2-light hover:text-link2hover-light dark:text-link2-dark dark:hover:text-link2hover-dark font-semibold" href="https://pypi.org/project/openai">pypi.org/project/openai</a></li>
</ul>
<h3>Making Localhost Accessible Over the Internet</h3>
<ol>
<li>Sign up at ngrok.com and get an access token.</li>
<li>Install ngrok from ngrok.com/download.</li>
<li>Run <code>ngrok config add-authtoken &lt;TOKEN&gt;</code>.</li>
<li>Start the service with <code>ngrok http http://localhost:8080</code> (adjust the port as necessary).</li>
</ol>
<p>Find detailed setup instructions at <a class="text-link2-light hover:text-link2hover-light dark:text-link2-dark dark:hover:text-link2hover-dark font-semibold" href="https://ngrok.com/docs/getting-started">ngrok documentation</a>.</p>
<h3>Coding the App</h3>
<p>I won&#x27;t show the entire source code here, this is what GitHub is for. Find the code at: <a class="text-link2-light hover:text-link2hover-light dark:text-link2-dark dark:hover:text-link2hover-dark font-semibold" href="https://github.com/HouseMDAI/house-ios/tree/main/HouseMDAI">HouseMDAI iOS App</a>. Instead, I&#x27;ll focus only on the important (IMO) points.</p>
<p>Let&#x27;s start with a quick description of the task: we need an app with a textfield on the home screen, ability to ask a set of dynamic questions, and show the answer. Also, we require a one-time onboarding. Okay, let&#x27;s code.</p>
<p>First thing first, we need some models, and they are pretty simple (KISS principle).</p>
<pre><code class="language-swift">struct Question {
    var text: String
}

struct Answer {
    var text: String
}

struct Questionary {
    var questions: [Question]
}

struct FilledQuestionary {
    var filledQuestions: [String: String]
}
</code></pre>
<p>Now, let&#x27;s do the onboarding. Keep following the KISS and SRP (Single Responsibility Principle), no business logic in views either, only UI. In this case, just the list of questions with scroll. All data and logic is delegated to the presenter. The only interesting thing here is a small helper method <code>bindingForQuestion</code>, which probably should be in the presenter but it doesn&#x27;t matter now.</p>
<pre><code class="language-swift">import SwiftUI

struct OnboardingView: View {

    @StateObject var presenter: OnboardingPresenter

    var body: some View {
        ScrollView {
            Spacer()
            VStack {
                ForEach(presenter.questions.questions) { question in
                    VStack {
                        Text(question.text)
                        TextField(&quot;&quot;, text: bindingForQuestion(question))
                            .formItem()
                    }
                    .padding()
                }
            }.padding()

            Button(&quot;Save&quot;, action: presenter.save)
            Spacer()
        }
    }

    private func bindingForQuestion(_ question: Question) -&gt; Binding&lt;String&gt; {
        Binding(
            get: { presenter.answers.filledQuestions[question.text] ?? &quot;&quot; },
            set: { presenter.answers.filledQuestions[question.text] = $0 }
        )
    }
}
</code></pre>
<p>You will be surprised, but there is no business logic in the presenter either!</p>
<pre><code class="language-swift">class OnboardingPresenter: ObservableObject {

    @Published public var answers: FilledQuestionary
    private(set) public var questions: Questionary
    private var completion: (FilledQuestionary) -&gt; Void

    init(questions: Questionary, answers: FilledQuestionary, completion: @escaping (FilledQuestionary) -&gt; Void) {
        self.questions = questions
        self.answers = answers
        self.completion = completion
    }

    func save() {
        completion(answers)
    }
}
</code></pre>
<p>Still everything is <em>simple, stupid</em>, and have only a <em>single responsibility</em>. Presenter must contain only the logic of its view. App-level business-logic is out of its jurisdiction, so the presenter is just delegating it to the top.</p>
<p>Also, you can see that both View and Presenter don&#x27;t instantiate any of the dependencies but receive them as init parameters. This follows the Dependency Inversion Principle, where high-level modules should not depend on low-level modules, but both should depend on abstractions. This allows for flexibility and easier testing, as well as making it straightforward to replace dependencies or inject mocks for testing purposes.</p>
<p>Using the Dependency Injection Pattern, dependencies are provided from outside the class rather than being instantiated internally. This promotes decoupling and allows for easier maintenance and testing.</p>
<p>Although protocols are not explicitly used in this example, it&#x27;s worth mentioning that protocols can play a crucial role in code, especially for abstraction and easier testing. By defining protocols for views, presenters, and dependencies, it becomes easier to swap out implementations or provide mocks during testing.</p>
<blockquote>
<p>If you&#x27;re considering using protocols in SwiftUI Views, there&#x27;s an important consideration to keep in mind. Since View in SwiftUI is a structure, it requires explicit specification of its property types. This means you&#x27;ll need to make it a generic structure and pass the type through all the call stack, resulting in a lot of boilerplate code.</p>
<p>However, there&#x27;s an alternative approach offered by <a class="text-link2-light hover:text-link2hover-light dark:text-link2-dark dark:hover:text-link2hover-dark font-semibold" href="https://github.com/MarkParker5/AnyObservableObject">MarkParker5/AnyObservableObject</a>. This library works similarly to native SwiftUI property wrappers but removes the compile-time type check in favor of a runtime one. While this approach may introduce some risks, they are easily mitigated by writing elementary Xcode tests that simply instantiate the views in the same way you do it at runtime.</p>
<p>By using this alternative, you can simplify your code and streamline the process of working with protocols in SwiftUI Views.</p>
</blockquote>
<p>So, if the presenter doesn&#x27;t contain the business logic, then who does? This is the task for the domain layer, which usually contains Services, Providers, and Managers. They have very similar destiny and the difference between them still is a subject of discussions. Let&#x27;s create the <code>OnboardingProvider</code> that will contain all business-logic of the onboarding process.</p>
<pre><code class="language-swift">class OnboardingProvider: ObservableObject {

    init() {
        loadFilledOnboardingFromDefaults()
    }

    // MARK: Interface

	@Published private(set) var needsOnboarding: Bool = true

    private(set) var filledOnboarding: FilledQuestionary? {
        didSet {
            if let filledOnboarding {
                saveFilledOnboardingToDefaults(filledQuestionary: filledOnboarding)
            }
        }
    }

    func getOnboardingQuestionary() -&gt; Questionary {
        // NOTE: it&#x27;s better to take the questions from the backend
        Questionary(questions: [
            Question(text: &quot;sex&quot;),
            Question(text: &quot;age&quot;),
            Question(text: &quot;weight&quot;),
            Question(text: &quot;height&quot;),
            Question(text: &quot;special_conditions&quot;),
        ])
    }

    func saveOnboardingAnswers(filledQuestionary: FilledQuestionary) {
        needsOnboarding = false
        filledOnboarding = filledQuestionary
    }

    // MARK: - Private

    private func saveFilledOnboardingToDefaults(filledQuestionary: FilledQuestionary) {
        UserDefaults.standard.removeObject(forKey: &quot;filledOnboarding&quot;)
        let encoder = JSONEncoder()
        let encoded = try! encoder.encode(filledQuestionary)
        UserDefaults.standard.set(encoded, forKey: &quot;filledOnboarding&quot;)
    }

    private func loadFilledOnboardingFromDefaults() {
        guard let object = UserDefaults.standard.object(forKey: &quot;filledOnboarding&quot;) else {
            needsOnboarding = true
            return
        }
        let savedFilledQuestionary = object as! Data
        let decoder = JSONDecoder()
        let loadedQuestionary = try! decoder.decode(FilledQuestionary.self, from: savedFilledQuestionary)
        self.filledOnboarding = loadedQuestionary
        self.needsOnboarding = false
    }
}
</code></pre>
<p>Again, it handles only one responsibility: managing the business logic of the onboarding process. This <em>encapsulation</em> allows other classes to interact with it without needing to worry about its internal implementation details, promoting a cleaner and more maintainable codebase.</p>
<p>Now, let&#x27;s put everything together in the entry point.</p>
<pre><code class="language-swift">import SwiftUI

@main
struct HouseMDAI: App {

    @StateObject private var onboardingProvider: OnboardingProvider
    @StateObject private var onboardingPresenter: OnboardingPresenter
    @StateObject private var homePresenter: HomePresenter

    init() {
        let onboardingProvider = OnboardingProvider()

        let onboardingPresenter = OnboardingPresenter(
            questions: onboardingProvider.getOnboardingQuestionary(),
            answers: FilledQuestionary(filledQuestions: [:]),
            completion: onboardingProvider.saveOnboardingAnswers
        )

	    let doctor = BackendDoctorProvider(baseUrl: &quot;http://localhost:8000&quot;)
        let homePresenter = HomePresenter(doctor: doctor)

        _onboardingProvider = StateObject(wrappedValue: onboardingProvider)
        _onboardingPresenter = StateObject(wrappedValue: onboardingPresenter)
        _homePresenter = StateObject(wrappedValue: homePresenter)
    }

    var body: some Scene {
        WindowGroup {
            if onboardingProvider.needsOnboarding {
                OnboardingView(presenter: onboardingPresenter)
            } else {
                TabView {
                    HomeView(presenter: homePresenter)
                    if let profile = onboardingProvider.filledOnboarding {
                        ProfileView(profile: profile)
                    }
                }
            }
        }
    } // body
}
</code></pre>
<p>This SwiftUI app sets up its initial state using <code>StateObject</code> property wrappers. It initializes an <code>OnboardingProvider</code>, <code>OnboardingPresenter</code>, and <code>HomePresenter</code> in its init method. The <code>OnboardingProvider</code> is responsible for managing onboarding-related data, while the <code>OnboardingPresenter</code> handles the logic for the onboarding view. The <code>HomePresenter</code> manages the main home view.</p>
<p>The body of the app&#x27;s scene checks if onboarding is needed. If so, it presents the <code>OnboardingView</code> with the <code>OnboardingPresenter</code>. Otherwise, it presents a <code>TabView</code> containing the <code>HomeView</code> with the <code>HomePresenter</code> and, if available, the <code>ProfileView</code>.</p>
<p>Now it&#x27;s time for the home view. The logic is simple:</p>
<ol>
<li>Get a message from user</li>
<li>Using the message, request a list of questions from the backend</li>
<li>Show the questions one by one using the native push navigation</li>
<li>Add answers to the request and repeat 2-4 until the backend-doctor returns a final result</li>
<li>Show the final result</li>
</ol>
<pre><code class="language-swift">struct HomeView: View {

    @StateObject var presenter: HomePresenter

    var body: some View {
        NavigationStack(path: $presenter.navigationPath) {
            VStack {
	            // 1
                Text(&quot;How are you?&quot;)
                TextField(&quot;...&quot;, text: $presenter.message)
                    .lineLimit(5...10)
                    .formItem()

				// 2
                Button(&quot;Send&quot;, action: presenter.onSend)
            }
            .padding()
            .navigationDestination(for: NavigationPage.self) { page in
                switch page {
                case .questinary(let questions, let answers):
	                // 3
                    QuestionaryView(
                        presenter: QuestionaryPresenter(
                            questions: questions,
                            answers: answers,
                            completion: presenter.onQuestionaryFilled
                        )
                    )
                case .answer(let string):
	                // 5
                    VStack {
                        Text(&quot;The doctor says...&quot;)
                        Text(string)
                            .font(.title2)
                            .padding()
                    }
                }
            }
        }
    }
}
</code></pre>
<p>Looks like I&#x27;ve missed the 4th point... or not? Since the view can&#x27;t content any logic, this part in handled by its presenter.</p>
<pre><code class="language-swift">enum NavigationPage: Hashable {
    case questinary(Questionary, FilledQuestionary)
    case answer(String)
}

class HomePresenter: ObservableObject {

    @Published var message: String = &quot;&quot;
    @Published var navigationPath: [NavigationPage] = []

    private let doctor: any DoctorProvider

    init(message: String = &quot;&quot;, doctor: any DoctorProvider) {
        self.message = message
        self.doctor = doctor
    }

    func onSend() {
        Task {
            let answer = try! await doctor.sendMessage(message: message)

            switch answer {
            case .questions(let questions):
                navigationPath.append(.questinary(questions, FilledQuestionary(filledQuestions: [:])))
            case .answer(let string):
                navigationPath.append(.answer(string))
            }
        }
    }

    func onQuestionaryFilled(filled: FilledQuestionary) {
        Task {
            let answer = try! await doctor.sendAnswers(message: message, answers: filled)

            switch answer {
            case .questions(let newQuestions):
                navigationPath.append(.questinary(newQuestions, filled))
            case .answer(let string):
                navigationPath.append(.answer(string))
            }
        }
    }
}
</code></pre>
<p>It manages the user&#x27;s message input and updates the navigation path based on responses from the backend.</p>
<p>Upon sending a message, the <code>onSend()</code> method sends the message to the backend using the <code>DoctorProvider</code> and awaits a response. Depending on the response type, it updates the navigation path to either display a set of questions or show a final answer.</p>
<p>Similarly, when a questionary is filled, the <code>onQuestionaryFilled()</code> method sends the filled questionary to the backend and updates the navigation path accordingly.</p>
<p>There&#x27;s a slight code duplication here between the <code>onSend()</code> and <code>onQuestionaryFilled()</code> methods, which could be refactored into a single method to handle both cases (DRY principle - Don&#x27;t Repeat Yourself). However, this is left as an exercise for further refinement.</p>
<p>The Questionary module (View+Presenter) is almost a copy of the Onboarding and simply delegates the logic up to <code>HomePresenter</code>, so I don&#x27;t see a need to show the code. Again, there is github for that.</p>
<p>The last things I want to show are two implementations of <code>DoctorProvider</code> which the only responsibility is to call the API and return <code>DoctorResponse</code>.</p>
<pre><code class="language-swift">protocol DoctorProvider {
    func sendMessage(message: String) async throws -&gt; DoctorResponse
    func sendAnswers(message: String, answers: FilledQuestionary) async throws -&gt; DoctorResponse
}

enum DoctorResponse {
    case questions(Questionary)
    case answer(String)
}
</code></pre>
<p>The first one uses our backend:</p>
<pre><code class="language-swift">class BackendDoctorProvider: DoctorProvider {

    private let baseUrl: String

    init(baseUrl: String) {
        self.baseUrl = baseUrl
    }

    func sendMessage(message: String) async throws -&gt; DoctorResponse {
        try! await sendAnswers(message: message, answers: FilledQuestionary(filledQuestions: [:]))
    }

    func sendAnswers(message: String, answers: FilledQuestionary) async throws -&gt; DoctorResponse {

        struct DoctorParams: Codable {
            var message: String
            var userCard: [String: String]
            var filledQuestionary: FilledQuestionary
        }

        let onboard = OnboardingProvider() // TODO: DI

        let paramsObject = DoctorParams(
            message: message,
            userCard: onboard.filledOnboarding!.filledQuestions,
            filledQuestionary: answers
        )

        let encoder = JSONParameterEncoder.default
        encoder.encoder.keyEncodingStrategy = .convertToSnakeCase

        let responseString = try await AF.request(
            baseUrl + &quot;/doctor&quot;,
            method: .post,
            parameters: paramsObject,
            encoder: encoder
        ).serializingString().value

        return try! DoctorResponse(from: responseString)
    }
}
</code></pre>
<p>The second one calls openai api directly (backendless approach) and is almost a copy of the prompting module from the backend.</p>
<pre><code class="language-swift">class PromptsProvider {

    private(set) public var homeRole = &quot;&quot; // TODO: take from the backend

    func message(message: String) -&gt; String {
        return message
    }

    func profile(profile: FilledQuestionary) -&gt; String {
        return try! jsonify(object: profile)
    }

    func answers(filled: FilledQuestionary) -&gt; String {
        return try! jsonify(object: filled)
    }

    // MARK: - Private

    private func jsonify(object: Encodable) throws -&gt; String {
        let coder = JSONEncoder()
        return String(data: try coder.encode(object), encoding: .utf8) ?? &quot;&quot;
    }
}

class DirectDoctorProvider: DoctorProvider {

    private var openAI: OpenAI

    init(apiToken: String) {
        openAI = OpenAI(apiToken: apiToken)
    }

    func sendMessage(message: String) async throws -&gt; DoctorResponse {
        try! await sendAnswers(message: message, answers: FilledQuestionary(filledQuestions: [:]))
    }

    func sendAnswers(message: String, answers: FilledQuestionary) async throws -&gt; DoctorResponse {
        let promptProvider = PromptsProvider() // TODO: DI
        let profile = OnboardingProvider().filledOnboarding! // TODO: DI

        let query = ChatQuery(model: .gpt3_5Turbo, messages: [
            Chat(role: .system, content: promptProvider.homeRole),
            Chat(role: .user, content: promptProvider.profile(profile: profile)),
            Chat(role: .user, content: promptProvider.message(message: message)),
            Chat(role: .user, content: promptProvider.answers(filled: answers)),
        ])

        let result = try await openAI.chats(query: query)
        return try! DoctorResponse(from: result.choices[0].message.content ?? &quot;&quot;)
    }
}
</code></pre>
<p>Both classes implement the same protocol and are easily interchangeable via DI.</p>
<pre><code class="language-swift">let doctor = BackendDoctorProvider(baseUrl: &quot;http://localhost:8000&quot;)
let homePresenter = HomePresenter(doctor: doctor)
</code></pre>
<pre><code class="language-swift">let doctor = DirectDoctorProvider(apiToken: &quot;&quot;)
let homePresenter = HomePresenter(doctor: doctor)
</code></pre>
<h3>Another Example</h3>
<p>Explore a more refined example of this architecture in my project TwiTreads at <a class="text-link2-light hover:text-link2hover-light dark:text-link2-dark dark:hover:text-link2hover-dark font-semibold" href="https://github.com/MarkParker5/TwiTreads">github.com/MarkParker5/TwiTreads</a></p>
<h3>What to Do Next</h3>
<ul>
<li>Integrate authentication and user database into the backend. Utilize the official FastAPI&#x27;s template from <a class="text-link2-light hover:text-link2hover-light dark:text-link2-dark dark:hover:text-link2hover-dark font-semibold" href="https://fastapi.tiangolo.com/project-generation">FastAPI Project Generation</a>.</li>
<li>Implement authentication flow in the app.</li>
<li>Focus on enhancing the app&#x27;s design to improve user experience. Let&#x27;s make beautiful apps!</li>
</ul>
<h2>Conclusion</h2>
<p>The projects and code links included serve as real-world examples to jumpstart your own development. Remember, the beauty of technology lies in iteration. Start simple, build a prototype, and continuously refine it. Each step forward brings you closer to mastering the art of software development and potentially the next big breakthrough in tech. Happy coding!</p></div><hr class="mx-auto w-3/4 h-1px border-t-1 border-faded my-10"/><div class="mt-5 mb-3 text-center"><p class="mb-2">Read, comment, and subscribe on:</p><div class="inline-flex gap-5 items-center flex-wrap"><a href="https://twitter.com/markparker5/status/1795095306758926812" title="Twitter" class="" target="_blank"><i class="fab fa-twitter fa-xl"></i></a><a href="https://markparker5.medium.com/ai-powered-mobile-app-with-backend-in-two-days-mvvmp-architecture-overview-tutorial-cdaa51fb9216" title="Medium" class="" target="_blank"><i class="fab fa-medium fa-xl"></i></a><a href="https://markparker5.hashnode.dev/ai-powered-mobile-app-with-backend-in-two-days-mvvmp-architecture-overview-tutorial" title="Hashnode" class="" target="_blank"><i class="fab fa-hashnode fa-xl"></i></a><a href="https://dev.to/markparker5/ai-powered-mobile-app-with-backend-in-two-days-mvvmp-architecture-overview-tutorial-mh1" title="Dev.to" class="" target="_blank"><i class="fab fa-dev fa-xl"></i></a><a href="https://habr.com/ru/articles/816345/" title="Habr" class="" target="_blank"><i class="fas fa-comment fa-xl"></i></a></div></div><hr class="mx-auto w-3/4 h-1px border-t-1 border-faded my-10"/><div><h4 class="text-l mb-4">Other articles:</h4><div class="mx-auto font-serif"><ul><li class="text-xl mb-8 list-none"><a class="text-link2-light hover:text-link2hover-light dark:text-link2-dark dark:hover:text-link2hover-dark font-semibold" href="/blog/python-architecture-essentials-building-scalable-and-clean-application-for-juniors">Python Architecture Essentials: Building Scalable and Clean Applications for Juniors</a><span class="block text-base italic opacity-50">— <!-- -->May 18th, 2024<!-- --> · <!-- -->20 min<!-- --> read</span><span class="block text-base">Dive into the fundamentals of scalable and clean application architecture in Python. Here, we explore essential concepts of OOP, SOLID principles, and Dependency Injection with practical examples of a real application structure.</span></li><li class="text-xl mb-8 list-none"><a class="text-link2-light hover:text-link2hover-light dark:text-link2-dark dark:hover:text-link2hover-dark font-semibold" href="/blog/house-md-ai-diagnostician-in-your-phone-passing-the-torch-and-entrusting-a-startup-to-capable-hands">Dr. House — AI Diagnostician in your phone. Passing the Torch and Entrusting a Startup to Capable Hands</a><span class="block text-base italic opacity-50">— <!-- -->May 4th, 2024<!-- --> · <!-- -->4 min<!-- --> read</span><span class="block text-base">This article picks up where the previous one left off, [How We Built an AI Startup in a Weekend Hackathon in Germany], focusing more on the final product rather than the hackathon process itself.</span></li><li class="text-xl mb-8 list-none"><a class="text-link2-light hover:text-link2hover-light dark:text-link2-dark dark:hover:text-link2hover-dark font-semibold" href="/blog/how-we-built-an-ai-startup-in-a-weekend-hackathon-in-germany">How We Built an AI Startup in a Weekend Hackathon in Germany</a><span class="block text-base italic opacity-50">— <!-- -->May 4th, 2024<!-- --> · <!-- -->9 min<!-- --> read</span><span class="block text-base">Here&#x27;s a rundown of my weekend at a Cologne hackathon, where we aimed to start an AI startup in just two days. We went from pitching ideas on Friday night to demoing a working app by Sunday. It involved coding late into the night, figuring out last-minute tech snags, and even putting together a presentation minutes before our demo. As a bonus, I have highlighted a to-do list of the main points for creating a startup.</span></li></ul></div></div></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"article":{"id":"ai-powered-mobile-app-with-backend-in-two-days-tutorial","date":"2024-5-5","date_pretty":"May 5th, 2024","read_time":"15 min","title":"AI-powered Mobile App with Backend in Two Days (Tutorial)","description":"This article delves into the nuts and bolts of creating a Proof of Concept (PoC) of a mobile app built with SwiftUI framework and a backend using FastAPI. As an extra, I'll demonstrate effective architecture patterns for SwiftUI apps, specifically MVVMP combined with SOLID principles and Dependency Injection (DI). For android, the code can be easily translated to Kotlin using Jetpack Compose Framework almost without changes.","keywords":["AI app development","AI startup development","Backend for mobile app","ChatGPT in mobile apps","clean code","Code architecture in app development","Debugging","Decoupling","Dependency Injection","Design patterns","DRY principle","Encapsulation","FastAPI","FastAPI backend development","good software architecture","Hackathon","Hackathon project guide","Healthcare mobile app development","iOS app","iOS app development","KISS principle","Minimal Viable Product development","MVP","OpenAI API integration","PoC","Proof of Concept app","Proof of Concept app development","Protocol-oriented programming","Python","Rapid prototyping","Refactoring","software architecture","Software development best practices","Software engineering","SwiftUI","SwiftUI MVVMP pattern","SwiftUI tutorial","Tutorial for app developers","Xcode"],"tweetId":"1795095306758926812","mediumUrl":"https://markparker5.medium.com/ai-powered-mobile-app-with-backend-in-two-days-mvvmp-architecture-overview-tutorial-cdaa51fb9216","devtoUrl":"https://dev.to/markparker5/ai-powered-mobile-app-with-backend-in-two-days-mvvmp-architecture-overview-tutorial-mh1","hashnodeUrl":"https://markparker5.hashnode.dev/ai-powered-mobile-app-with-backend-in-two-days-mvvmp-architecture-overview-tutorial","habrUrl":"https://habr.com/ru/articles/816345/","mirrors":[{"url":"https://twitter.com/markparker5/status/1795095306758926812","title":"Twitter","icon":"fab fa-twitter"},{"url":"https://markparker5.medium.com/ai-powered-mobile-app-with-backend-in-two-days-mvvmp-architecture-overview-tutorial-cdaa51fb9216","title":"Medium","icon":"fab fa-medium"},{"url":"https://markparker5.hashnode.dev/ai-powered-mobile-app-with-backend-in-two-days-mvvmp-architecture-overview-tutorial","title":"Hashnode","icon":"fab fa-hashnode"},{"url":"https://dev.to/markparker5/ai-powered-mobile-app-with-backend-in-two-days-mvvmp-architecture-overview-tutorial-mh1","title":"Dev.to","icon":"fab fa-dev"},{"url":"https://habr.com/ru/articles/816345/","title":"Habr","icon":"fas fa-comment"}]},"mdxBody":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    ul: \"ul\",\n    li: \"li\",\n    a: \"a\",\n    h2: \"h2\",\n    ol: \"ol\",\n    strong: \"strong\",\n    h3: \"h3\",\n    pre: \"pre\",\n    code: \"code\",\n    em: \"em\",\n    blockquote: \"blockquote\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"Previous articles:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"/blog/how-we-built-an-ai-startup-in-a-weekend-hackathon-in-germany\",\n          children: \"How We Built an AI Startup in a Weekend Hackathon in Germany\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"/blog/house-md-ai-diagnostician-in-your-phone-passing-the-torch-and-entrusting-a-startup-to-capable-hands\",\n          children: \"Dr. House - AI Diagnostician in Your Phone: Passing the Startup Torch\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This article delves into the nuts and bolts of creating a Proof of Concept (PoC) of a mobile app built with the SwiftUI framework and a backend using FastAPI. As an extra, I'll demonstrate effective architecture patterns for SwiftUI apps, specifically MVVMP combined with SOLID principles and Dependency Injection (DI). For android, the code can be easily translated to Kotlin using Jetpack Compose Framework almost without changes.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Why We Need a Backend\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Someone might say that you can just cram all the logic into the application, send requests to chatgpt directly and make a backendless app. And I agree, it is indeed possible (and I'll show it later), but the backend provides several important advantages.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The backend serves as the backbone for any sophisticated app, especially those requiring secure data management, business logic processing, and service integration. Here’s why a robust backend is crucial:\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"Security\"\n          }), \": A backend helps protect sensitive data and user authentication tokens from MITM (Man-in-the-Middle) attacks. It acts as a secure gateway between the user's device and the database or external services, ensuring that all data exchanges are encrypted and authenticated.\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"Control Over Service Usage\"\n          }), \": By managing APIs and user interactions through the backend, you can monitor and control how the app is used. This includes throttling to manage load, preventing abuse, and ensuring that resources are used efficiently.\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"Database Integration\"\n          }), \": A backend allows for seamless integration with databases, enabling dynamic data storage, retrieval, and real-time updates. This is essential for apps that require user accounts, store user preferences, or need to retrieve large amounts of data quickly and securely.\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"Subscription and Freemium Models\"\n          }), \": Implementing subscription services or a freemium model requires a backend to handle billing, track usage, and manage user tiers. The backend can securely process payments and subscriptions, providing a seamless user experience while ensuring compliance with data protection regulations.\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"Scalability and Maintenance\"\n          }), \": With a backend, you can scale your application more effectively. Server-side logic can be updated without needing to push updates to the client, facilitating easier maintenance and quicker rollouts of new features.\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In essence, a backend is not just about functionality — it's about creating a secure, scalable, and sustainable environment for your app to thrive.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Explaining the Tech Stack\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"SwiftUI\"\n        }), \": The go-to for native iOS apps now that UIKit is on its way out. It's declarative and streamlined, with XCode as the indispensable editor. For android, the code can be easily translated to Kotlin using Jetpack Compose.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"FastAPI\"\n        }), \": Chosen for the backend for its speed, minimal boilerplate, and declarative nature, edited with the superb Zed.dev.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"ChatGPT API\"\n        }), \": Used here as a large language model (LLM); choice may vary based on the need for customization (see [Technical Info](github.com/HouseMDAI/house-notebook/blob/main/Technical Info.md)).\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Ngrok\"\n        }), \": Implements tunneling with a simple CLI command to expose your local server to the internet.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Building the iOS App\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Theory: Architecture Patterns\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"Model View ViewModel Presenter (MVVMP)\"\n          }), \":\"]\n        }), \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: \"Model\"\n            }), \": Represents the data structures used in the app, such as Question, Answer, Questionary, and FilledQuestionary. These models are simple and only hold data, following the KISS principle.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: \"View\"\n            }), \": SwiftUI views are responsible only for UI presentation and delegate all data and logic to presenters. They contain no business logic and are designed to be simple and focused on UI rendering.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: \"ViewModel\"\n            }), \": In SwiftUI, ViewModel is represented by ObservableObject, which serves as a data-only observable model. No methods or logic here.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: \"Presenter\"\n            }), \": The Presenter manages all logic related to the module (screen or view), but not the business logic. It communicates with the domain layer for business logic operations, such as interacting with APIs or managing data persistence.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: \"Domain Layer\"\n            }), \": This layer encapsulates the business logic of the application and interacts with external resources such as databases, APIs, or other services. It consists of several components, such as Services, Providers, Managers, Repositories, Mappers, Factories, etc.\"]\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"Actually, the MP in MVVMP stands for Mark Parker and the full form is \\\"Model View ViewModel by Mark Parker\\\"\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"SOLID Principles\"\n          }), \":\"]\n        }), \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: \"Single-responsibility Principle\"\n            }), \": Each class should have only one reason to change.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: \"Open-closed Principle\"\n            }), \": Components should be open for extension but closed for modification.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: \"Liskov Substitution Principle\"\n            }), \": Objects of a superclass should be replaceable with objects of subclasses.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: \"Interface Segregation Principle\"\n            }), \": No client should be forced to depend on interfaces it doesn't use.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: \"Dependency Inversion Principle\"\n            }), \": Depend on abstractions, not concretes, facilitated by DI.\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"Dependency Injection (DI)\"\n          }), \": a programming technique in which an object or function receives other objects or functions that it requires, as opposed to creating them internally.\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Drafting the Backend\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.a, {\n        href: \"https://github.com/HouseMDAI/house-backend/blob/master/backend\",\n        children: \"backend's code\"\n      }), \" is quite simple. Endpoints (main.py):\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-python\",\n        children: \"from typing import Callable\\nimport json\\nfrom fastapi import FastAPI, Body, Request, Response\\nfrom .models import (Question, FilledQuestionary, DoctorResponseAnswer, DoctorResponseQuestionary)\\nfrom .user_card import UserCardSimple\\nfrom .prompting import get_response\\n\\n\\n@app.get(\\\"/onboarding\\\", response_model = DoctorResponseQuestionary)\\ndef onboarding():\\n    return DoctorResponseQuestionary(question=[Question(text=text) for text in UserCardSimple.__fields__.keys()])\\n\\n@app.post(\\\"/doctor\\\")\\ndef doctor(user_card: UserCardSimple, filled_questionary: FilledQuestionary, message: str = Body(...)):\\n    json_string = get_response(user_card, message, filled_questionary)\\n    loaded = json.loads(json_string.strip())\\n    return loaded\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"There are two endpoints. The \\\"onboarding\\\" provides a list of anamnesis questions that needs to be filled at the first launch of the app. Answers will be stored on the device and used for personalized future diagnosis. The \\\"doctor\\\" is the main endpoint: it generates questions based on earlier answers and user's card, or returns the result of diagnosis.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Models:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-python\",\n        children: \"from pydantic import BaseModel\\n\\n\\nclass Question(BaseModel):\\n    text: str\\n\\nclass FilledQuestionary(BaseModel):\\n    filled_questions: dict[str, str]\\n\\nclass DoctorResponseAnswer(BaseModel):\\n    text: str\\n\\nclass DoctorResponseQuestionary(BaseModel):\\n    questions: list[str]\\n\\nclass UserCardSimple(BaseModel):\\n    sex: str\\n    age: int\\n    weight: int\\n    height: int\\n    special_conditions: str\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Prompting:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-python\",\n        children: \"import os\\nfrom openai import OpenAI\\nfrom .models import FilledQuestionary\\n\\n\\napi_key = os.environ.get(\\\"API_KEY\\\")\\nclient = OpenAI(api_key=api_key)\\n\\ndef get_response(user_card: str, message: str, filled_questionary: FilledQuestionary, max_tokens=200):\\n    format_question = \\\"\\\"\\\"{\\\"questions\\\":[{\\\"text\\\":\\\"first question\\\"},{\\\"text\\\":\\\"second question\\\"}]}\\\"\\\"\\\"\\n    format_advice = \\\"\\\"\\\"{\\\"text\\\":\\\"Advice: Drink more water\\\"}\\\"\\\"\\\"\\n\\n    system_prompt = f\\\"\\\"\\\"\\n    You are a doctor that gives user an opportunity to swiftly check up health and diagnos an illness using anamnes and a short questionary.\\n    Your task is to ask short questions and give your opinion and advices.\\n    Your questions are accamulated in the filled questionary, which is empty in the first itteration.\\n\\n    Strive to about 1-2 questions per iteration and up to 6 questions in total (can be less). Questions must be short, clear, shouldn't repeat,\\n    and should be relevant to the user's health condition, and should require easy answers.\\n    Ask questions only in the json format {format_question}.\\n\\n    Number of answered questions: {len(filled_questionary.filled_questions)}\\n    If the Number of answered questions is more then 6, you should stop asking questions an`d provide an give your final opinion,\\n    an assumption or an advice in the json format {format_advice}.\\n    \\\"\\\"\\\"\\n\\n    prompt = f\\\"\\\"\\\"request message: {message}; anamnesis: {user_card}; filled questionary: {filled_questionary};\\\"\\\"\\\"\\n\\n    chat_completion = client.chat.completions.create(\\n        messages=[\\n            {\\n                \\\"role\\\": \\\"system\\\",\\n                \\\"content\\\": f\\\"{system_prompt}\\\",\\n            },\\n            {\\n                \\\"role\\\": \\\"user\\\",\\n                \\\"content\\\": f\\\"{prompt}\\\",\\n            },\\n        ],\\n        model=\\\"gpt-3.5-turbo\\\",\\n        max_tokens=max_tokens\\n    )\\n    return chat_completion.choices[0].message.content\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The prompting module utilizes OpenAI's GPT-3.5 to generate responses based on user input, anamnesis, and filled questionnaires. It prompts the user with relevant questions and advice for health diagnosis. As you can see, there is nothing complicated here. The code is elementary, and the prompt is just a set of clear instructions for the LLM.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Setup the env and run the server using \", _jsx(_components.code, {\n        children: \"fastapi dev main.py\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Details:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://fastapi.tiangolo.com/tutorial/first-steps\",\n          children: \"fastapi.tiangolo.com/tutorial/first-steps\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://pypi.org/project/openai\",\n          children: \"pypi.org/project/openai\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Making Localhost Accessible Over the Internet\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Sign up at ngrok.com and get an access token.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Install ngrok from ngrok.com/download.\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Run \", _jsx(_components.code, {\n          children: \"ngrok config add-authtoken \u003cTOKEN\u003e\"\n        }), \".\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Start the service with \", _jsx(_components.code, {\n          children: \"ngrok http http://localhost:8080\"\n        }), \" (adjust the port as necessary).\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Find detailed setup instructions at \", _jsx(_components.a, {\n        href: \"https://ngrok.com/docs/getting-started\",\n        children: \"ngrok documentation\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Coding the App\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"I won't show the entire source code here, this is what GitHub is for. Find the code at: \", _jsx(_components.a, {\n        href: \"https://github.com/HouseMDAI/house-ios/tree/main/HouseMDAI\",\n        children: \"HouseMDAI iOS App\"\n      }), \". Instead, I'll focus only on the important (IMO) points.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Let's start with a quick description of the task: we need an app with a textfield on the home screen, ability to ask a set of dynamic questions, and show the answer. Also, we require a one-time onboarding. Okay, let's code.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"First thing first, we need some models, and they are pretty simple (KISS principle).\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-swift\",\n        children: \"struct Question {\\n    var text: String\\n}\\n\\nstruct Answer {\\n    var text: String\\n}\\n\\nstruct Questionary {\\n    var questions: [Question]\\n}\\n\\nstruct FilledQuestionary {\\n    var filledQuestions: [String: String]\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Now, let's do the onboarding. Keep following the KISS and SRP (Single Responsibility Principle), no business logic in views either, only UI. In this case, just the list of questions with scroll. All data and logic is delegated to the presenter. The only interesting thing here is a small helper method \", _jsx(_components.code, {\n        children: \"bindingForQuestion\"\n      }), \", which probably should be in the presenter but it doesn't matter now.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-swift\",\n        children: \"import SwiftUI\\n\\nstruct OnboardingView: View {\\n\\n    @StateObject var presenter: OnboardingPresenter\\n\\n    var body: some View {\\n        ScrollView {\\n            Spacer()\\n            VStack {\\n                ForEach(presenter.questions.questions) { question in\\n                    VStack {\\n                        Text(question.text)\\n                        TextField(\\\"\\\", text: bindingForQuestion(question))\\n                            .formItem()\\n                    }\\n                    .padding()\\n                }\\n            }.padding()\\n\\n            Button(\\\"Save\\\", action: presenter.save)\\n            Spacer()\\n        }\\n    }\\n\\n    private func bindingForQuestion(_ question: Question) -\u003e Binding\u003cString\u003e {\\n        Binding(\\n            get: { presenter.answers.filledQuestions[question.text] ?? \\\"\\\" },\\n            set: { presenter.answers.filledQuestions[question.text] = $0 }\\n        )\\n    }\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"You will be surprised, but there is no business logic in the presenter either!\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-swift\",\n        children: \"class OnboardingPresenter: ObservableObject {\\n\\n    @Published public var answers: FilledQuestionary\\n    private(set) public var questions: Questionary\\n    private var completion: (FilledQuestionary) -\u003e Void\\n\\n    init(questions: Questionary, answers: FilledQuestionary, completion: @escaping (FilledQuestionary) -\u003e Void) {\\n        self.questions = questions\\n        self.answers = answers\\n        self.completion = completion\\n    }\\n\\n    func save() {\\n        completion(answers)\\n    }\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Still everything is \", _jsx(_components.em, {\n        children: \"simple, stupid\"\n      }), \", and have only a \", _jsx(_components.em, {\n        children: \"single responsibility\"\n      }), \". Presenter must contain only the logic of its view. App-level business-logic is out of its jurisdiction, so the presenter is just delegating it to the top.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Also, you can see that both View and Presenter don't instantiate any of the dependencies but receive them as init parameters. This follows the Dependency Inversion Principle, where high-level modules should not depend on low-level modules, but both should depend on abstractions. This allows for flexibility and easier testing, as well as making it straightforward to replace dependencies or inject mocks for testing purposes.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Using the Dependency Injection Pattern, dependencies are provided from outside the class rather than being instantiated internally. This promotes decoupling and allows for easier maintenance and testing.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Although protocols are not explicitly used in this example, it's worth mentioning that protocols can play a crucial role in code, especially for abstraction and easier testing. By defining protocols for views, presenters, and dependencies, it becomes easier to swap out implementations or provide mocks during testing.\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"If you're considering using protocols in SwiftUI Views, there's an important consideration to keep in mind. Since View in SwiftUI is a structure, it requires explicit specification of its property types. This means you'll need to make it a generic structure and pass the type through all the call stack, resulting in a lot of boilerplate code.\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"However, there's an alternative approach offered by \", _jsx(_components.a, {\n          href: \"https://github.com/MarkParker5/AnyObservableObject\",\n          children: \"MarkParker5/AnyObservableObject\"\n        }), \". This library works similarly to native SwiftUI property wrappers but removes the compile-time type check in favor of a runtime one. While this approach may introduce some risks, they are easily mitigated by writing elementary Xcode tests that simply instantiate the views in the same way you do it at runtime.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"By using this alternative, you can simplify your code and streamline the process of working with protocols in SwiftUI Views.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"So, if the presenter doesn't contain the business logic, then who does? This is the task for the domain layer, which usually contains Services, Providers, and Managers. They have very similar destiny and the difference between them still is a subject of discussions. Let's create the \", _jsx(_components.code, {\n        children: \"OnboardingProvider\"\n      }), \" that will contain all business-logic of the onboarding process.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-swift\",\n        children: \"class OnboardingProvider: ObservableObject {\\n\\n    init() {\\n        loadFilledOnboardingFromDefaults()\\n    }\\n\\n    // MARK: Interface\\n\\n\\t@Published private(set) var needsOnboarding: Bool = true\\n\\n    private(set) var filledOnboarding: FilledQuestionary? {\\n        didSet {\\n            if let filledOnboarding {\\n                saveFilledOnboardingToDefaults(filledQuestionary: filledOnboarding)\\n            }\\n        }\\n    }\\n\\n    func getOnboardingQuestionary() -\u003e Questionary {\\n        // NOTE: it's better to take the questions from the backend\\n        Questionary(questions: [\\n            Question(text: \\\"sex\\\"),\\n            Question(text: \\\"age\\\"),\\n            Question(text: \\\"weight\\\"),\\n            Question(text: \\\"height\\\"),\\n            Question(text: \\\"special_conditions\\\"),\\n        ])\\n    }\\n\\n    func saveOnboardingAnswers(filledQuestionary: FilledQuestionary) {\\n        needsOnboarding = false\\n        filledOnboarding = filledQuestionary\\n    }\\n\\n    // MARK: - Private\\n\\n    private func saveFilledOnboardingToDefaults(filledQuestionary: FilledQuestionary) {\\n        UserDefaults.standard.removeObject(forKey: \\\"filledOnboarding\\\")\\n        let encoder = JSONEncoder()\\n        let encoded = try! encoder.encode(filledQuestionary)\\n        UserDefaults.standard.set(encoded, forKey: \\\"filledOnboarding\\\")\\n    }\\n\\n    private func loadFilledOnboardingFromDefaults() {\\n        guard let object = UserDefaults.standard.object(forKey: \\\"filledOnboarding\\\") else {\\n            needsOnboarding = true\\n            return\\n        }\\n        let savedFilledQuestionary = object as! Data\\n        let decoder = JSONDecoder()\\n        let loadedQuestionary = try! decoder.decode(FilledQuestionary.self, from: savedFilledQuestionary)\\n        self.filledOnboarding = loadedQuestionary\\n        self.needsOnboarding = false\\n    }\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Again, it handles only one responsibility: managing the business logic of the onboarding process. This \", _jsx(_components.em, {\n        children: \"encapsulation\"\n      }), \" allows other classes to interact with it without needing to worry about its internal implementation details, promoting a cleaner and more maintainable codebase.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now, let's put everything together in the entry point.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-swift\",\n        children: \"import SwiftUI\\n\\n@main\\nstruct HouseMDAI: App {\\n\\n    @StateObject private var onboardingProvider: OnboardingProvider\\n    @StateObject private var onboardingPresenter: OnboardingPresenter\\n    @StateObject private var homePresenter: HomePresenter\\n\\n    init() {\\n        let onboardingProvider = OnboardingProvider()\\n\\n        let onboardingPresenter = OnboardingPresenter(\\n            questions: onboardingProvider.getOnboardingQuestionary(),\\n            answers: FilledQuestionary(filledQuestions: [:]),\\n            completion: onboardingProvider.saveOnboardingAnswers\\n        )\\n\\n\\t    let doctor = BackendDoctorProvider(baseUrl: \\\"http://localhost:8000\\\")\\n        let homePresenter = HomePresenter(doctor: doctor)\\n\\n        _onboardingProvider = StateObject(wrappedValue: onboardingProvider)\\n        _onboardingPresenter = StateObject(wrappedValue: onboardingPresenter)\\n        _homePresenter = StateObject(wrappedValue: homePresenter)\\n    }\\n\\n    var body: some Scene {\\n        WindowGroup {\\n            if onboardingProvider.needsOnboarding {\\n                OnboardingView(presenter: onboardingPresenter)\\n            } else {\\n                TabView {\\n                    HomeView(presenter: homePresenter)\\n                    if let profile = onboardingProvider.filledOnboarding {\\n                        ProfileView(profile: profile)\\n                    }\\n                }\\n            }\\n        }\\n    } // body\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This SwiftUI app sets up its initial state using \", _jsx(_components.code, {\n        children: \"StateObject\"\n      }), \" property wrappers. It initializes an \", _jsx(_components.code, {\n        children: \"OnboardingProvider\"\n      }), \", \", _jsx(_components.code, {\n        children: \"OnboardingPresenter\"\n      }), \", and \", _jsx(_components.code, {\n        children: \"HomePresenter\"\n      }), \" in its init method. The \", _jsx(_components.code, {\n        children: \"OnboardingProvider\"\n      }), \" is responsible for managing onboarding-related data, while the \", _jsx(_components.code, {\n        children: \"OnboardingPresenter\"\n      }), \" handles the logic for the onboarding view. The \", _jsx(_components.code, {\n        children: \"HomePresenter\"\n      }), \" manages the main home view.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The body of the app's scene checks if onboarding is needed. If so, it presents the \", _jsx(_components.code, {\n        children: \"OnboardingView\"\n      }), \" with the \", _jsx(_components.code, {\n        children: \"OnboardingPresenter\"\n      }), \". Otherwise, it presents a \", _jsx(_components.code, {\n        children: \"TabView\"\n      }), \" containing the \", _jsx(_components.code, {\n        children: \"HomeView\"\n      }), \" with the \", _jsx(_components.code, {\n        children: \"HomePresenter\"\n      }), \" and, if available, the \", _jsx(_components.code, {\n        children: \"ProfileView\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now it's time for the home view. The logic is simple:\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Get a message from user\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Using the message, request a list of questions from the backend\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Show the questions one by one using the native push navigation\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Add answers to the request and repeat 2-4 until the backend-doctor returns a final result\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Show the final result\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-swift\",\n        children: \"struct HomeView: View {\\n\\n    @StateObject var presenter: HomePresenter\\n\\n    var body: some View {\\n        NavigationStack(path: $presenter.navigationPath) {\\n            VStack {\\n\\t            // 1\\n                Text(\\\"How are you?\\\")\\n                TextField(\\\"...\\\", text: $presenter.message)\\n                    .lineLimit(5...10)\\n                    .formItem()\\n\\n\\t\\t\\t\\t// 2\\n                Button(\\\"Send\\\", action: presenter.onSend)\\n            }\\n            .padding()\\n            .navigationDestination(for: NavigationPage.self) { page in\\n                switch page {\\n                case .questinary(let questions, let answers):\\n\\t                // 3\\n                    QuestionaryView(\\n                        presenter: QuestionaryPresenter(\\n                            questions: questions,\\n                            answers: answers,\\n                            completion: presenter.onQuestionaryFilled\\n                        )\\n                    )\\n                case .answer(let string):\\n\\t                // 5\\n                    VStack {\\n                        Text(\\\"The doctor says...\\\")\\n                        Text(string)\\n                            .font(.title2)\\n                            .padding()\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Looks like I've missed the 4th point... or not? Since the view can't content any logic, this part in handled by its presenter.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-swift\",\n        children: \"enum NavigationPage: Hashable {\\n    case questinary(Questionary, FilledQuestionary)\\n    case answer(String)\\n}\\n\\nclass HomePresenter: ObservableObject {\\n\\n    @Published var message: String = \\\"\\\"\\n    @Published var navigationPath: [NavigationPage] = []\\n\\n    private let doctor: any DoctorProvider\\n\\n    init(message: String = \\\"\\\", doctor: any DoctorProvider) {\\n        self.message = message\\n        self.doctor = doctor\\n    }\\n\\n    func onSend() {\\n        Task {\\n            let answer = try! await doctor.sendMessage(message: message)\\n\\n            switch answer {\\n            case .questions(let questions):\\n                navigationPath.append(.questinary(questions, FilledQuestionary(filledQuestions: [:])))\\n            case .answer(let string):\\n                navigationPath.append(.answer(string))\\n            }\\n        }\\n    }\\n\\n    func onQuestionaryFilled(filled: FilledQuestionary) {\\n        Task {\\n            let answer = try! await doctor.sendAnswers(message: message, answers: filled)\\n\\n            switch answer {\\n            case .questions(let newQuestions):\\n                navigationPath.append(.questinary(newQuestions, filled))\\n            case .answer(let string):\\n                navigationPath.append(.answer(string))\\n            }\\n        }\\n    }\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"It manages the user's message input and updates the navigation path based on responses from the backend.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Upon sending a message, the \", _jsx(_components.code, {\n        children: \"onSend()\"\n      }), \" method sends the message to the backend using the \", _jsx(_components.code, {\n        children: \"DoctorProvider\"\n      }), \" and awaits a response. Depending on the response type, it updates the navigation path to either display a set of questions or show a final answer.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Similarly, when a questionary is filled, the \", _jsx(_components.code, {\n        children: \"onQuestionaryFilled()\"\n      }), \" method sends the filled questionary to the backend and updates the navigation path accordingly.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"There's a slight code duplication here between the \", _jsx(_components.code, {\n        children: \"onSend()\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"onQuestionaryFilled()\"\n      }), \" methods, which could be refactored into a single method to handle both cases (DRY principle - Don't Repeat Yourself). However, this is left as an exercise for further refinement.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The Questionary module (View+Presenter) is almost a copy of the Onboarding and simply delegates the logic up to \", _jsx(_components.code, {\n        children: \"HomePresenter\"\n      }), \", so I don't see a need to show the code. Again, there is github for that.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The last things I want to show are two implementations of \", _jsx(_components.code, {\n        children: \"DoctorProvider\"\n      }), \" which the only responsibility is to call the API and return \", _jsx(_components.code, {\n        children: \"DoctorResponse\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-swift\",\n        children: \"protocol DoctorProvider {\\n    func sendMessage(message: String) async throws -\u003e DoctorResponse\\n    func sendAnswers(message: String, answers: FilledQuestionary) async throws -\u003e DoctorResponse\\n}\\n\\nenum DoctorResponse {\\n    case questions(Questionary)\\n    case answer(String)\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The first one uses our backend:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-swift\",\n        children: \"class BackendDoctorProvider: DoctorProvider {\\n\\n    private let baseUrl: String\\n\\n    init(baseUrl: String) {\\n        self.baseUrl = baseUrl\\n    }\\n\\n    func sendMessage(message: String) async throws -\u003e DoctorResponse {\\n        try! await sendAnswers(message: message, answers: FilledQuestionary(filledQuestions: [:]))\\n    }\\n\\n    func sendAnswers(message: String, answers: FilledQuestionary) async throws -\u003e DoctorResponse {\\n\\n        struct DoctorParams: Codable {\\n            var message: String\\n            var userCard: [String: String]\\n            var filledQuestionary: FilledQuestionary\\n        }\\n\\n        let onboard = OnboardingProvider() // TODO: DI\\n\\n        let paramsObject = DoctorParams(\\n            message: message,\\n            userCard: onboard.filledOnboarding!.filledQuestions,\\n            filledQuestionary: answers\\n        )\\n\\n        let encoder = JSONParameterEncoder.default\\n        encoder.encoder.keyEncodingStrategy = .convertToSnakeCase\\n\\n        let responseString = try await AF.request(\\n            baseUrl + \\\"/doctor\\\",\\n            method: .post,\\n            parameters: paramsObject,\\n            encoder: encoder\\n        ).serializingString().value\\n\\n        return try! DoctorResponse(from: responseString)\\n    }\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The second one calls openai api directly (backendless approach) and is almost a copy of the prompting module from the backend.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-swift\",\n        children: \"class PromptsProvider {\\n\\n    private(set) public var homeRole = \\\"\\\" // TODO: take from the backend\\n\\n    func message(message: String) -\u003e String {\\n        return message\\n    }\\n\\n    func profile(profile: FilledQuestionary) -\u003e String {\\n        return try! jsonify(object: profile)\\n    }\\n\\n    func answers(filled: FilledQuestionary) -\u003e String {\\n        return try! jsonify(object: filled)\\n    }\\n\\n    // MARK: - Private\\n\\n    private func jsonify(object: Encodable) throws -\u003e String {\\n        let coder = JSONEncoder()\\n        return String(data: try coder.encode(object), encoding: .utf8) ?? \\\"\\\"\\n    }\\n}\\n\\nclass DirectDoctorProvider: DoctorProvider {\\n\\n    private var openAI: OpenAI\\n\\n    init(apiToken: String) {\\n        openAI = OpenAI(apiToken: apiToken)\\n    }\\n\\n    func sendMessage(message: String) async throws -\u003e DoctorResponse {\\n        try! await sendAnswers(message: message, answers: FilledQuestionary(filledQuestions: [:]))\\n    }\\n\\n    func sendAnswers(message: String, answers: FilledQuestionary) async throws -\u003e DoctorResponse {\\n        let promptProvider = PromptsProvider() // TODO: DI\\n        let profile = OnboardingProvider().filledOnboarding! // TODO: DI\\n\\n        let query = ChatQuery(model: .gpt3_5Turbo, messages: [\\n            Chat(role: .system, content: promptProvider.homeRole),\\n            Chat(role: .user, content: promptProvider.profile(profile: profile)),\\n            Chat(role: .user, content: promptProvider.message(message: message)),\\n            Chat(role: .user, content: promptProvider.answers(filled: answers)),\\n        ])\\n\\n        let result = try await openAI.chats(query: query)\\n        return try! DoctorResponse(from: result.choices[0].message.content ?? \\\"\\\")\\n    }\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Both classes implement the same protocol and are easily interchangeable via DI.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-swift\",\n        children: \"let doctor = BackendDoctorProvider(baseUrl: \\\"http://localhost:8000\\\")\\nlet homePresenter = HomePresenter(doctor: doctor)\\n\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-swift\",\n        children: \"let doctor = DirectDoctorProvider(apiToken: \\\"\\\")\\nlet homePresenter = HomePresenter(doctor: doctor)\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Another Example\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Explore a more refined example of this architecture in my project TwiTreads at \", _jsx(_components.a, {\n        href: \"https://github.com/MarkParker5/TwiTreads\",\n        children: \"github.com/MarkParker5/TwiTreads\"\n      })]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"What to Do Next\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"Integrate authentication and user database into the backend. Utilize the official FastAPI's template from \", _jsx(_components.a, {\n          href: \"https://fastapi.tiangolo.com/project-generation\",\n          children: \"FastAPI Project Generation\"\n        }), \".\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Implement authentication flow in the app.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Focus on enhancing the app's design to improve user experience. Let's make beautiful apps!\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Conclusion\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The projects and code links included serve as real-world examples to jumpstart your own development. Remember, the beauty of technology lies in iteration. Start simple, build a prototype, and continuously refine it. Each step forward brings you closer to mastering the art of software development and potentially the next big breakthrough in tech. Happy coding!\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"ai-powered-mobile-app-with-backend-in-two-days-tutorial"},"buildId":"KuUflqe93Wvy0Z8W9uWO2","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>